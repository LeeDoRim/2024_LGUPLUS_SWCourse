# [2024.08.21(수)] 연관관계 매핑(ManyToOneOneToMany/ManyToMany)


# JPABasic_9_ManyToOneOneToMany_BI 프로젝트 생성

- JPABasic_8_OneToMany 프로젝트 복사하여 JPABasic_9_ManyToOneOneToMany 프로젝트 생성
- jpa_basic_9 스키마 생성

### src/main/java/com/mycom/myapp

### config/MyPersistenceUnitInfo.java

```java
package com.mycom.myapp.config;

import java.net.URL;
import java.util.List;
import java.util.Properties;

import javax.sql.DataSource;

import com.zaxxer.hikari.HikariDataSource;

import jakarta.persistence.SharedCacheMode;
import jakarta.persistence.ValidationMode;
import jakarta.persistence.spi.ClassTransformer;
import jakarta.persistence.spi.PersistenceUnitInfo;
import jakarta.persistence.spi.PersistenceUnitTransactionType;

// META-INF/persistence.xml 대체
public class MyPersistenceUnitInfo implements PersistenceUnitInfo {

	@Override
	public String getPersistenceUnitName() {
		return "my-pu";
	}

	@Override
	public String getPersistenceProviderClassName() {
		return "org.hibernate.jpa.HibernatePersistenceProvider";
	}

	@Override
	public PersistenceUnitTransactionType getTransactionType() {
		return PersistenceUnitTransactionType.RESOURCE_LOCAL;
	}

	@Override
	public DataSource getJtaDataSource() {
		HikariDataSource dataSource = new HikariDataSource();
		dataSource.setJdbcUrl("jdbc:mysql://localhost:3306/jpa_basic_9");
		dataSource.setUsername("root");
		dataSource.setPassword("root");
		return dataSource;
	}

	@Override
	public DataSource getNonJtaDataSource() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<String> getMappingFileNames() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<URL> getJarFileUrls() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public URL getPersistenceUnitRootUrl() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<String> getManagedClassNames() {
		return List.of("com.mycom.myapp.entity.Post", "com.mycom.myapp.entity.Comment");
	}

	@Override
	public boolean excludeUnlistedClasses() {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public SharedCacheMode getSharedCacheMode() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public ValidationMode getValidationMode() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Properties getProperties() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public String getPersistenceXMLSchemaVersion() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public ClassLoader getClassLoader() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void addTransformer(ClassTransformer transformer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public ClassLoader getNewTempClassLoader() {
		// TODO Auto-generated method stub
		return null;
	}

}

```

### entity/Post.java

```java
package com.mycom.myapp.entity;

import java.util.List;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.OneToMany;

// Non-Owner Entity
@Entity
public class Post {
	
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private int id;
	
	private String title;
	
	private String content;

	// #1 ~ #9
	@OneToMany(mappedBy = "post")  // bi-directional relationship 규정 ( Comment Entity의 자신 Post 필드명 )
	private List<Comment> comments;
	
	// #10
//	@OneToMany(cascade = CascadeType.PERSIST)  
//	private List<Comment> comments;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getTitle() {
		return title;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	public List<Comment> getComments() {
		return comments;
	}

	public void setComments(List<Comment> comments) {
		this.comments = comments;
	}

	@Override
	public String toString() {
		return "Post [id=" + id + ", title=" + title + ", content=" + content + "]";
	}
	
}
```

### entity/Comment.java

```java
package com.mycom.myapp.entity;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;

// Owner Entity
@Entity
public class Comment {

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private int id;

	private String content;
	
	// #1 ~ #8, #10
//	@ManyToOne
//	@JoinColumn(name = "post_id")  // 생성되는 Comment table에 post_id 컬럼이 생성 (FK 역할)
//	private Post post;
	
	// #9
	@ManyToOne(cascade = CascadeType.PERSIST)
	@JoinColumn(name = "post_id")  // 생성되는 Comment table에 post_id 컬럼이 생성 (FK 역할)
	private Post post;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	public Post getPost() {
		return post;
	}

	public void setPost(Post post) {
		this.post = post;
	}

	@Override
	public String toString() {
		return "Comment [id=" + id + ", content=" + content + "]";
	}

}

```

### Test.java

```java
package com.mycom.myapp;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.hibernate.jpa.HibernatePersistenceProvider;

import com.mycom.myapp.config.MyPersistenceUnitInfo;
import com.mycom.myapp.entity.Comment;
import com.mycom.myapp.entity.Post;

import jakarta.persistence.EntityManager;
import jakarta.persistence.EntityManagerFactory;

public class Test {

	public static void main(String[] args) {

		Map<String, String> props = new HashMap<>();
		props.put("hibernate.show_sql", "true");	// sql 명령문을 확인할 수 있다.
		props.put("hibernate.hbm2ddl.auto", "create");	// 속성에 create, update 등이 올 수 있다.
		
		EntityManagerFactory emf = new HibernatePersistenceProvider().createContainerEntityManagerFactory(new MyPersistenceUnitInfo(), props);
		EntityManager em = emf.createEntityManager();
		
		try {
			em.getTransaction().begin();
			
			// #1 
			// 테이블 생성 확인
			{
				/*
				 * Hibernate: create table Comment (id integer not null auto_increment, post_id integer, content varchar(255), primary key (id)) engine=InnoDB
					Hibernate: create table Post (id integer not null auto_increment, content varchar(255), title varchar(255), primary key (id)) engine=InnoDB
					Hibernate: alter table Comment add constraint FKqb0rnht649ifuh6gev5lwvx8x foreign key (post_id) references Post (id)
				 */
			}
			
			// #2 
			// Post Entity persist
			// Post insert 1 건 OK
//			{
//				Post p = new Post();
//				p.setTitle("Post 1");
//				p.setContent("Post 1 Content");
//				
//				em.persist(p);
//				
//				/*
//				 * Hibernate: insert into Post (content,title) values (?,?)
//				 */
//			}
			
			// #3 
			// Comment Entity 2 persist
			// Comment insert 2 건 OK <= 정상적인 데이터 X
			// 만약 DB comment table의 post_id 칼럼이 not null인 경우 오류 발생
			// java.sql.SQLIntegrityConstraintViolationException: Column 'post_id' cannot be null
//			{
//				Comment c1 = new Comment();
//				c1.setContent("Comment 1 content");
//				
//				Comment c2 = new Comment();
//				c2.setContent("Comment 2 content");
//
//				em.persist(c1);
//				em.persist(c2);
//
//				/*
//				 * Hibernate: insert into Comment (content,post_id) values (?,?)
//					Hibernate: insert into Comment (content,post_id) values (?,?)
//				 */
//			}
			
			// #4 
			// Post 1, Comment Entity 2 Entity 생성 
			// Post, Comment 연결 (Post 중심)
			// Post만 persist 
			// Post 1 건만 insert
			// @OneToMany uni(JPABasic_8_OneToMany Test.java의 5번) 실습에서는 오류 발생 
			// (이유 : Post가 Owner Entity이기 때문에 Comment도 같이 persist되어야 했다.)
			// @OneToMany와 @ManyToOne의 bi 관계이고 @OneToMany가 Non Owner Entity이므로.
//			{
//				Post p = new Post();
//				p.setTitle("Post 1");
//				p.setContent("Post 1 Content");
//				
//				Comment c1 = new Comment();
//				c1.setContent("Comment 1 content");
//
//				Comment c2 = new Comment();
//				c2.setContent("Comment 2 content");
//
//				// Post 중심 연결
//				p.setComments(List.of(c1, c2));
//				
//				// Post만 persist
//				em.persist(p);
//
//				/*
//				 * Hibernate: insert into Post (content,title) values (?,?)
//				 */
//			}
			
			// #5 
			// Post 1, Comment Entity 2 Entity 생성
			// Post, Comment 연결 (Comment 중심)
			// Comment만 persist
			// 오류 발생
			// org.hibernate.TransientPropertyValueException: object references an unsaved transient instance - save the transient instance before flushing : com.mycom.myapp.entity.Comment.post -> com.mycom.myapp.entity.Post
//			{
//				Post p = new Post();
//				p.setTitle("Post 1");
//				p.setContent("Post 1 Content");
//
//				Comment c1 = new Comment();
//				c1.setContent("Comment 1 content");
//
//				Comment c2 = new Comment();
//				c2.setContent("Comment 2 content");
//
//				// Comment 중심 연결
//				c1.setPost(p);
//				c2.setPost(p);
//
//				// Post만 persist
//				em.persist(c1);
//				em.persist(c2);
//
//			}
			
			// #6 
			// Post 1, Comment Entity 2 Entity 생성
			// Post, Comment 둘 다 모두 연결 
			// Post, Comment 모두 persist (Comment -> Post 순)
			// 
//			{
//				Post p = new Post();
//				p.setTitle("Post 1");
//				p.setContent("Post 1 Content");
//
//				Comment c1 = new Comment();
//				c1.setContent("Comment 1 content");
//
//				Comment c2 = new Comment();
//				c2.setContent("Comment 2 content");
//
//				// Post, Comment 모두 연결
//				p.setComments(List.of(c1, c2));
//				c1.setPost(p);
//				c2.setPost(p);
//
//				// Post, Comment 모두 persist
//				em.persist(c1);
//				em.persist(c2);
//				em.persist(p);  // 뒤에 persist
//
//				/* 만약 post_id 칼럼이 not null이면 오류가 발생한다.
//				 * Hibernate: insert into Comment (content,post_id) values (?,?)
//					Hibernate: insert into Comment (content,post_id) values (?,?)
//					Hibernate: insert into Post (content,title) values (?,?)
//					Hibernate: update Comment set content=?,post_id=? where id=?
//					Hibernate: update Comment set content=?,post_id=? where id=?
//				 */
//			}
			
			// #7 
			// Post 1, Comment Entity 2 Entity 생성
			// Post, Comment 둘 다 모두 연결
			// Post, Comment 모두 persist (Post -> Comment 순)
			// #6에 비해 더 나은 방법
//			{
//				Post p = new Post();
//				p.setTitle("Post 1");
//				p.setContent("Post 1 Content");
//
//				Comment c1 = new Comment();
//				c1.setContent("Comment 1 content");
//
//				Comment c2 = new Comment();
//				c2.setContent("Comment 2 content");
//
//				// Post, Comment 모두 연결
//				p.setComments(List.of(c1, c2));
//				c1.setPost(p);
//				c2.setPost(p);
//
//				// Post, Comment 모두 persist
//				em.persist(p); // 먼저 persist
//				em.persist(c1);
//				em.persist(c2);
//
//				/*
//				 * Hibernate: insert into Post (content,title) values (?,?)
//					Hibernate: insert into Comment (content,post_id) values (?,?)
//					Hibernate: insert into Comment (content,post_id) values (?,?)
//				 */
//			}
			
			// #8 
			// Post 1, Comment Entity 2 Entity 생성
			// Comment 만 연결
			// Post, Comment 모두 persist (Post -> Comment 순)
			// #7의 코드 중 persist 관련 Post 중심의 연결 코드는 필요 X
//			{
//				Post p = new Post();
//				p.setTitle("Post 1");
//				p.setContent("Post 1 Content");
//
//				Comment c1 = new Comment();
//				c1.setContent("Comment 1 content");
//
//				Comment c2 = new Comment();
//				c2.setContent("Comment 2 content");
//
//				// Comment 만 연결
////				p.setComments(List.of(c1, c2));  // 불필요한 코드
//				c1.setPost(p);
//				c2.setPost(p);
//
//				// Post, Comment 모두 persist
//				em.persist(p); // 먼저 persist
//				em.persist(c1);
//				em.persist(c2);
//
//				/*
//				 * Hibernate: insert into Post (content,title) values (?,?)
//					Hibernate: insert into Comment (content,post_id) values (?,?)
//					Hibernate: insert into Comment (content,post_id) values (?,?)
//				 */
//			}
			
			// #9
			// Comment에 cascadeType PERSIST
			// Post 1, Comment Entity 2 Entity 생성
			// Post, Comment 연결 (Comment 중심)
			// Comment만 persist
			// 3 건 insert OK
			{
				Post p = new Post();
				p.setTitle("Post 1");
				p.setContent("Post 1 Content");

				Comment c1 = new Comment();
				c1.setContent("Comment 1 content");

				Comment c2 = new Comment();
				c2.setContent("Comment 2 content");

				// Comment 중심 연결
				c1.setPost(p);
				c2.setPost(p);

				// Comment만 persist
				em.persist(c1);
				em.persist(c2);
				
				/*
				 * Hibernate: insert into Post (content,title) values (?,?)
					Hibernate: insert into Comment (content,post_id) values (?,?)
					Hibernate: insert into Comment (content,post_id) values (?,?)
				 */

			}
			
			// #10
			// Post에 cascadeType PERSIST 추가 mappedBy = "post" 제거, Comment는 원복
			// Post 1, Comment Entity 2 Entity 생성
			// Post, Comment 연결 (Post 중심)
			// Post만 persist
			// Post 가 Owner Entity 가 되고,  @OneToMany 처럼 join column  이 아닌 join table 을 별도로 구성하게 된다. 주의!!!
			// 오류는 나지 않지만 문제가 발생할 수 있다.
//			{
//				Post p = new Post();
//				p.setTitle("Post 1");
//				p.setContent("Post 1 Content");
//
//				Comment c1 = new Comment();
//				c1.setContent("Comment 1 content");
//
//				Comment c2 = new Comment();
//				c2.setContent("Comment 2 content");
//
//				// Post 중심 연결
//				p.setComments(List.of(c1, c2));
//
//				// Post만 persist
//				em.persist(p);
//
//				/*
//				 * Hibernate: insert into Post (content,title) values (?,?)
//					Hibernate: insert into Comment (content,post_id) values (?,?)
//					Hibernate: insert into Comment (content,post_id) values (?,?)
//					Hibernate: insert into Post_Comment (Post_id,comments_id) values (?,?)
//					Hibernate: insert into Post_Comment (Post_id,comments_id) values (?,?)
//				 */
//
//			}
			
			em.getTransaction().commit(); // update 수행
			
		} finally {
			em.close();
		}
		
	}

}
```

### 단방향 @OneToMany와 양방향 @OneToMany 및 @ManyToOne 관계에서 Post만 persist했을 때의 차이

### 1. **단방향 `@OneToMany` 관계**

### 문제 상황

```java
java코드 복사
Post p = new Post();
p.setTitle("Post 1");
p.setContent("Post 1 Content");

Comment c1 = new Comment();
c1.setContent("comment 1 Content");

Comment c2 = new Comment();
c2.setContent("comment 2 Content");

// 연결
p.setComments(List.of(c1, c2));

em.persist(p); // Post만 persist

```

이 코드에서 **Post** 엔티티만 `persist`하려고 할 때 오류가 발생합니다.

### 오류 원인

- **단방향 `@OneToMany`** 관계에서는 **Post** 엔티티에 **Comment** 엔티티 목록이 포함되어 있지만, **Comment** 엔티티가 외래 키를 가지지 않기 때문에 **Post** 엔티티가 소유하는 **Comment** 엔티티를 자동으로 저장하지 않습니다.
- 즉, `p.setComments(List.of(c1, c2));`를 통해 **Post**가 **Comment** 엔티티와 연결되었지만, **Comment** 엔티티는 데이터베이스에 `persist`되지 않은 상태입니다. 이 상태에서 **Post**를 `persist`하려고 하면, 하이버네이트는 **Post**에 포함된 **Comment** 엔티티가 `Transient` 상태임을 인식하고, `TransientObjectException` 오류를 발생시킵니다.

### 해결 방법

- 이 문제를 해결하려면 **Comment** 엔티티들을 먼저 `persist`한 후에 **Post** 엔티티를 `persist`해야 합니다.

```java
java코드 복사
em.persist(c1);
em.persist(c2);
em.persist(p);

```

### 2. **양방향 `@OneToMany`와 `@ManyToOne` 관계**

### 문제 상황이 발생하지 않는 이유

```java
java코드 복사
Post p = new Post();
p.setTitle("Post 1");
p.setContent("Post 1 Content");

Comment c1 = new Comment();
c1.setContent("Comment 1 content");

Comment c2 = new Comment();
c2.setContent("Comment 2 content");

// Post 중심 연결
p.setComments(List.of(c1, c2));

// Post만 persist
em.persist(p);

```

이 코드에서는 **Post** 엔티티만 `persist`해도 문제가 발생하지 않습니다.

### 이유

- **양방향 `@OneToMany`와 `@ManyToOne` 관계**에서는 **Comment** 엔티티가 `@ManyToOne`으로 **Post** 엔티티를 참조하고, **Comment** 엔티티가 외래 키를 관리하는 주체(Owner)입니다.
- **Post** 엔티티에 `cascade = CascadeType.PERSIST` 설정이 있다면, **Post** 엔티티를 `persist`할 때 연관된 **Comment** 엔티티들도 자동으로 `persist`됩니다.
- 이로 인해 **Post**와 함께 **Comment** 엔티티들도 데이터베이스에 저장되므로 오류가 발생하지 않습니다.

### 차이점 요약

- **단방향 `@OneToMany`**: `Post`만 `persist`할 경우 **Comment** 엔티티들이 `persist`되지 않아 `TransientObjectException`이 발생합니다. 이를 해결하려면 **Comment** 엔티티들을 명시적으로 `persist`해야 합니다.
- **양방향 `@OneToMany`와 `@ManyToOne`**: `Post`만 `persist`해도 하이버네이트가 **Comment** 엔티티들을 자동으로 `persist`합니다. 이때 오류가 발생하지 않습니다. 이 동작은 **Comment** 엔티티가 외래 키를 관리하는 주체이기 때문에 가능합니다.

### find

### src/main/java/com/mycom/myapp

### entity/Post.java

```java
package com.mycom.myapp.entity;

import java.util.List;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.OneToMany;

// Non-Owner Entity
@Entity
public class Post {
	
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private int id;
	
	private String title;
	
	private String content;

	// #1 ~ #9
	// #A, #B, #D
	@OneToMany(mappedBy = "post")  // bi-directional relationship 규정 ( Comment Entity의 자신 Post 필드명 )
	private List<Comment> comments;
	
	// #10
//	@OneToMany(cascade = CascadeType.PERSIST)  
//	private List<Comment> comments;
	
	// #C
//	@OneToMany(mappedBy = "post", fetch = FetchType.EAGER) 
//	private List<Comment> comments;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getTitle() {
		return title;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	public List<Comment> getComments() {
		return comments;
	}

	public void setComments(List<Comment> comments) {
		this.comments = comments;
	}

	@Override
	public String toString() {
		return "Post [id=" + id + ", title=" + title + ", content=" + content + "]";
	}
	
}
```

### entity/Comment.java

```java
package com.mycom.myapp.entity;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;

// Owner Entity
@Entity
public class Comment {

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private int id;

	private String content;
	
	// #1 ~ #8, #10
	// #A, #B, #C
//	@ManyToOne
//	@JoinColumn(name = "post_id")  // 생성되는 Comment table에 post_id 컬럼이 생성 (FK 역할)
//	private Post post;
	
	// #9
//	@ManyToOne(cascade = CascadeType.PERSIST)
//	@JoinColumn(name = "post_id")  // 생성되는 Comment table에 post_id 컬럼이 생성 (FK 역할)
//	private Post post;
	
	// #D
	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "post_id")  // 생성되는 Comment table에 post_id 컬럼이 생성 (FK 역할)
	private Post post;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	public Post getPost() {
		return post;
	}

	public void setPost(Post post) {
		this.post = post;
	}

	@Override
	public String toString() {
		return "Comment [id=" + id + ", content=" + content + "]";
	}

}
```

### Test2.java

```java
package com.mycom.myapp;

import java.util.HashMap;
import java.util.Map;

import org.hibernate.jpa.HibernatePersistenceProvider;

import com.mycom.myapp.config.MyPersistenceUnitInfo;
import com.mycom.myapp.entity.Comment;

import jakarta.persistence.EntityManager;
import jakarta.persistence.EntityManagerFactory;

public class Test2 {

	public static void main(String[] args) {

		Map<String, String> props = new HashMap<>();
		props.put("hibernate.show_sql", "true");	// sql 명령문을 확인할 수 있다.
//		props.put("hibernate.hbm2ddl.auto", "create");	// 속성에 create, update 등이 올 수 있다.
		
		EntityManagerFactory emf = new HibernatePersistenceProvider().createContainerEntityManagerFactory(new MyPersistenceUnitInfo(), props);
		EntityManager em = emf.createEntityManager();
		
		try {
			em.getTransaction().begin();
			
			// #A
			// Post find() 
			// Post만 가져오기
			// @OneToMany의 FetchType이 LAZY
//			{
//				Post post = em.find(Post.class, 1);
//				System.out.println(post);
//				
//				/* 실행 결과 (try 제외)
//				 * Hibernate: select p1_0.id,p1_0.content,p1_0.title from Post p1_0 where p1_0.id=?
//					Post [id=1, title=Post 1, content=Post 1 Content]
//				 */
//				
//				try {
//					Thread.sleep(5000);
//				}catch (Exception e) {
//					e.printStackTrace();
//				}
//				
//				// Comment가 필요할 때 다시 sql 수행
//				System.out.println(post.getComments());
//				
//				/* 실행 결과
//				 * Hibernate: select p1_0.id,p1_0.content,p1_0.title from Post p1_0 where p1_0.id=?
//					Post [id=1, title=Post 1, content=Post 1 Content]
//					Hibernate: select c1_0.post_id,c1_0.id,c1_0.content from Comment c1_0 where c1_0.post_id=?
//					[Comment [id=1, content=Comment 1 content], Comment [id=2, content=Comment 2 content]]
//				 */
//				
//			}
			
			// #B
			// Comment find()
			// @ManyToOne의 FetchType EAGER
			// join 수행, Post와 Comment를 같이 가져온다.
//			{
//				Comment c1 = em.find(Comment.class, 1);
//				System.out.println(c1);
//
//				/*
//				 * 실행 결과 (try 제외) 
//				 * Hibernate: select c1_0.id,c1_0.content,p1_0.id,p1_0.content,p1_0.title from Comment c1_0 left join Post p1_0 on p1_0.id=c1_0.post_id where c1_0.id=?
//					Comment [id=1, content=Comment 1 content]
//				 */
//
//				try {
//					Thread.sleep(5000);
//				} catch (Exception e) {
//					e.printStackTrace();
//				}
//
//				// Post 사용할 때 다시 SQL을 수행하지 않는다.
//				System.out.println(c1.getPost());
//
//				/*
//				 * 실행 결과 
//					Hibernate: select c1_0.id,c1_0.content,p1_0.id,p1_0.content,p1_0.title from Comment c1_0 left join Post p1_0 on p1_0.id=c1_0.post_id where c1_0.id=?
//					Comment [id=1, content=Comment 1 content]
//					Post [id=1, title=Post 1, content=Post 1 Content]
//				 */
//
//			}
			
			// #C
			// Post FetchType을 EAGER로 변경
			// Post find()
			// join 수행, 미리 Post와 Comment 모두 가져온다.
//			{
//				Post post = em.find(Post.class, 1);
//				System.out.println(post);
//
//				/*
//				 * 실행 결과 (try 제외) 
//					Hibernate: select p1_0.id,p1_0.content,p1_0.title,c1_0.post_id,c1_0.id,c1_0.content from Post p1_0 left join Comment c1_0 on p1_0.id=c1_0.post_id where p1_0.id=?
//					Post [id=1, title=Post 1, content=Post 1 Content]
//				 */
//
//				try {
//					Thread.sleep(5000);
//				} catch (Exception e) {
//					e.printStackTrace();
//				}
//
//				// Comment가 필요할 때 다시 sql 수행하지 않는다.
//				System.out.println(post.getComments());
//
//				/*
//				 * 실행 결과 
//					Hibernate: select p1_0.id,p1_0.content,p1_0.title,c1_0.post_id,c1_0.id,c1_0.content from Post p1_0 left join Comment c1_0 on p1_0.id=c1_0.post_id where p1_0.id=?
//					Post [id=1, title=Post 1, content=Post 1 Content]
//					[Comment [id=1, content=Comment 1 content], Comment [id=2, content=Comment 2 content]]
//				 */
//
//			}
			
			// #D
			// Comment FetchType을 LAZY로 변경
			// Comment find()
			// join 수행 X, Comment만 가져온다.
			{
				Comment c1 = em.find(Comment.class, 1);
				System.out.println(c1);

				/*
				 * 실행 결과 (try 제외) 
					Hibernate: select c1_0.id,c1_0.content,c1_0.post_id from Comment c1_0 where c1_0.id=?
					Comment [id=1, content=Comment 1 content]
				 */

				try {
					Thread.sleep(5000);
				} catch (Exception e) {
					e.printStackTrace();
				}

				// Post 사용할 때 다시 SQL을 수행하지 않는다.
				System.out.println(c1.getPost());

				/*
				 * 실행 결과 
					Hibernate: select c1_0.id,c1_0.content,c1_0.post_id from Comment c1_0 where c1_0.id=?
					Comment [id=1, content=Comment 1 content]
					Hibernate: select p1_0.id,p1_0.content,p1_0.title from Post p1_0 where p1_0.id=?
					Post [id=1, title=Post 1, content=Post 1 Content]
				 */

			}
			
			em.getTransaction().commit(); // update 수행
		} finally {
			em.close();
		}
		
	}

}
```

### 기존 Post 에 새 Comment 추가

### src/main/java/com/mycom/myapp

### Test3.java

```java
package com.mycom.myapp;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.hibernate.jpa.HibernatePersistenceProvider;

import com.mycom.myapp.config.MyPersistenceUnitInfo;
import com.mycom.myapp.entity.Comment;
import com.mycom.myapp.entity.Post;

import jakarta.persistence.EntityManager;
import jakarta.persistence.EntityManagerFactory;

public class Test3 {

	public static void main(String[] args) {

		Map<String, String> props = new HashMap<>();
		props.put("hibernate.show_sql", "true");	// sql 명령문을 확인할 수 있다.
//		props.put("hibernate.hbm2ddl.auto", "create");	// 속성에 create, update 등이 올 수 있다.
		
		EntityManagerFactory emf = new HibernatePersistenceProvider().createContainerEntityManagerFactory(new MyPersistenceUnitInfo(), props);
		EntityManager em = emf.createEntityManager();
		
		try {
			em.getTransaction().begin();
			
			// #가
			// 기존 Post 에 새 Comment 추가
			{
				// 기존 Post <- find()
				// 새 Comment <- Entity 객체 생성
				// Post Entity에 새 Comment Entity 연결 
				// 		Comment 중심 setPost() 이용
				// 새 Comment Entity를 persist
				
				Post p = em.find(Post.class, 1);

				Comment c3 = new Comment();
				c3.setContent("comment 3 Content");
				
				// 연결
				c3.setPost(p);
				
				// Comment persist
				em.persist(c3);

				/* 실행 결과
				 * Hibernate: select p1_0.id,p1_0.content,p1_0.title from Post p1_0 where p1_0.id=?
					Hibernate: insert into Comment (content,post_id) values (?,?)
				 */
				
			}
			
			em.getTransaction().commit(); // update 수행
		} finally {
			em.close();
		}
		
		
	}

}
```

# JPABasic_10_ManyToMany 프로젝트 생성

- JPABasic_9_ManyToOneOneToMany_BI 프로젝트 복사하여 JPABasic_10_ManyToMany 프로젝트 생성
- jpa_basic_10 스키마 생성
- entity 패키지에 생성한 클래스 모두 삭제

### src/main/java/com/mycom/myapp

### config/MyPersistenceUnitInfo.java

```java
package com.mycom.myapp.config;

import java.net.URL;
import java.util.List;
import java.util.Properties;

import javax.sql.DataSource;

import com.zaxxer.hikari.HikariDataSource;

import jakarta.persistence.SharedCacheMode;
import jakarta.persistence.ValidationMode;
import jakarta.persistence.spi.ClassTransformer;
import jakarta.persistence.spi.PersistenceUnitInfo;
import jakarta.persistence.spi.PersistenceUnitTransactionType;

// META-INF/persistence.xml 대체
public class MyPersistenceUnitInfo implements PersistenceUnitInfo {

	@Override
	public String getPersistenceUnitName() {
		return "my-pu";
	}

	@Override
	public String getPersistenceProviderClassName() {
		return "org.hibernate.jpa.HibernatePersistenceProvider";
	}

	@Override
	public PersistenceUnitTransactionType getTransactionType() {
		return PersistenceUnitTransactionType.RESOURCE_LOCAL;
	}

	@Override
	public DataSource getJtaDataSource() {
		HikariDataSource dataSource = new HikariDataSource();
		dataSource.setJdbcUrl("jdbc:mysql://localhost:3306/jpa_basic_10");
		dataSource.setUsername("root");
		dataSource.setPassword("root");
		return dataSource;
	}

	@Override
	public DataSource getNonJtaDataSource() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<String> getMappingFileNames() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<URL> getJarFileUrls() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public URL getPersistenceUnitRootUrl() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<String> getManagedClassNames() {
		return List.of("com.mycom.myapp.entity.Team", "com.mycom.myapp.entity.User");
	}

	@Override
	public boolean excludeUnlistedClasses() {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public SharedCacheMode getSharedCacheMode() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public ValidationMode getValidationMode() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Properties getProperties() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public String getPersistenceXMLSchemaVersion() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public ClassLoader getClassLoader() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void addTransformer(ClassTransformer transformer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public ClassLoader getNewTempClassLoader() {
		// TODO Auto-generated method stub
		return null;
	}

}
```

### entity/Team.java

```java
package com.mycom.myapp.entity;

import java.util.List;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.JoinTable;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.Table;

// Owner Entity
@Entity
@Table(name = "teams")
public class Team {
	
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private int id;
	
	private String name;
	
	// #1 ~ #8, #10
//	@ManyToMany
//	@JoinTable(
//			name = "teams_users",  // 다대다 두 entity를 연결해주는 중간 테이블 이름
//			joinColumns = @JoinColumn(name = "team_id"), // 중간 테이블에 생길 현재(Owner) entity를 가리키는 컬럼
//			inverseJoinColumns = @JoinColumn(name = "user_id") // 중간 테이블에 생길 상대(Non Owner) entity를 가리키는 컬럼
//	)
//	private List<User> users;
	
	// #9
	@ManyToMany(cascade = CascadeType.PERSIST)
	@JoinTable(
			name = "teams_users",  // 다대다 두 entity를 연결해주는 중간 테이블 이름
			joinColumns = @JoinColumn(name = "team_id"), // 중간 테이블에 생길 현재(Owner) entity를 가리키는 컬럼
			inverseJoinColumns = @JoinColumn(name = "user_id") // 중간 테이블에 생길 상대(Non Owner) entity를 가리키는 컬럼
	)
	private List<User> users;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public List<User> getUsers() {
		return users;
	}

	public void setUsers(List<User> users) {
		this.users = users;
	}

	@Override
	public String toString() {
		return "Team [id=" + id + ", name=" + name + "]";
	}

}

```

### entity/User.java

```java
package com.mycom.myapp.entity;

import java.util.List;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.Table;

// Non Owner Entity
@Entity
@Table(name = "users")
public class User {
	
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private int id;
	
	private String name;
	
	// #1 ~ #9
	@ManyToMany(mappedBy = "users")
	private List<Team> teams;
	
	// #10
//	@ManyToMany(mappedBy = "users", cascade = CascadeType.PERSIST)
//	private List<Team> teams;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public List<Team> getTeams() {
		return teams;
	}

	public void setTeams(List<Team> teams) {
		this.teams = teams;
	}

	@Override
	public String toString() {
		return "User [id=" + id + ", name=" + name + "]";
	}
	
}

```

### Test.java

```java
package com.mycom.myapp;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.hibernate.jpa.HibernatePersistenceProvider;

import com.mycom.myapp.config.MyPersistenceUnitInfo;
import com.mycom.myapp.entity.Team;
import com.mycom.myapp.entity.User;

import jakarta.persistence.EntityManager;
import jakarta.persistence.EntityManagerFactory;

public class Test {

	public static void main(String[] args) {

		Map<String, String> props = new HashMap<>();
		props.put("hibernate.show_sql", "true");	// sql 명령문을 확인할 수 있다.
		props.put("hibernate.hbm2ddl.auto", "create");	// 속성에 create, update 등이 올 수 있다.
		
		EntityManagerFactory emf = new HibernatePersistenceProvider().createContainerEntityManagerFactory(new MyPersistenceUnitInfo(), props);
		EntityManager em = emf.createEntityManager();
		
		try {
			em.getTransaction().begin();
			
			// #1 
			{
				/*
				 * Hibernate: create table teams (id integer not null auto_increment, name varchar(255), primary key (id)) engine=InnoDB
					Hibernate: create table teams_users (team_id integer not null, user_id integer not null) engine=InnoDB
					Hibernate: create table users (id integer not null auto_increment, name varchar(255), primary key (id)) engine=InnoDB
					Hibernate: alter table teams_users add constraint FK33un3b2rh2bomyb4qtq4vfbp foreign key (user_id) references users (id)
					Hibernate: alter table teams_users add constraint FK8yj6qxvi4tc32dta9qqk6yiky foreign key (team_id) references teams (id)
				 */
			}
			
			// #2
			// User Entity 생성, persist
			// User 2 건 insert OK
//			{
//				User u1 = new User();
//				u1.setName("User 1");
//				
//				User u2 = new User();
//				u2.setName("User 2");
//				
//				em.persist(u1);
//				em.persist(u2);
//				
//				/* 실행 결과
//				 * Hibernate: insert into users (name) values (?)
//					Hibernate: insert into users (name) values (?)
//				 */
//				
//			}
			
			// #3
			// Team Entity 생성, persist
			// Team 2 건 insert OK
//			{
//				Team t1 = new Team();
//				t1.setName("Team 1");
//
//				Team t2 = new Team();
//				t2.setName("Team 2");
//
//				em.persist(t1);
//				em.persist(t2);
//
//				/*
//				 * 실행 결과 
//					Hibernate: insert into teams (name) values (?)
//					Hibernate: insert into teams (name) values (?)
//
//				 */
//
//			}
			
			// #4
			// User Entity 2, Team Entity 2 생성, persist 4개
			// User 2 건, Team 2 건 insert OK
//			{
//				Team t1 = new Team();
//				t1.setName("Team 1");
//
//				Team t2 = new Team();
//				t2.setName("Team 2");
//
//				User u1 = new User();
//				u1.setName("User 1");
//				
//				User u2 = new User();
//				u2.setName("User 2");
//				
//				em.persist(u1);
//				em.persist(u2);
//				
//				em.persist(t1);
//				em.persist(t2);
//
//				/*
//				 * 실행 결과 
//					Hibernate: insert into users (name) values (?)
//					Hibernate: insert into users (name) values (?)
//					Hibernate: insert into teams (name) values (?)
//					Hibernate: insert into teams (name) values (?)
//				 * 
//				 */
//
//			}
			
			// #5
			// User Entity 2, Team Entity 2 생성
			// Team 중심 연결
			// persist 4개
//			{
//				Team t1 = new Team();
//				t1.setName("Team 1");
//
//				Team t2 = new Team();
//				t2.setName("Team 2");
//
//				User u1 = new User();
//				u1.setName("User 1");
//
//				User u2 = new User();
//				u2.setName("User 2");
//
//				// Team 중심 연결
//				t1.setUsers(List.of(u1, u2));
//				t2.setUsers(List.of(u2));
//				
//				// Team, User 모두 persist
//				em.persist(u1);
//				em.persist(u2);
//
//				em.persist(t1);
//				em.persist(t2);
//
//				/*
//				 * 실행 결과 
//					Hibernate: insert into users (name) values (?)
//					Hibernate: insert into users (name) values (?)
//					Hibernate: insert into teams (name) values (?)
//					Hibernate: insert into teams (name) values (?)
//					Hibernate: insert into teams_users (team_id,user_id) values (?,?)
//					Hibernate: insert into teams_users (team_id,user_id) values (?,?)
//					Hibernate: insert into teams_users (team_id,user_id) values (?,?)
//				 * 
//				 */
//
//			}
			
			// #6
			// User Entity 2, Team Entity 2 생성
			// Team 중심 연결
			// persist Team 2 개
			// 오류 발생
			// org.hibernate.TransientObjectException: object references an unsaved transient instance - save the transient instance before flushing: com.mycom.myapp.entity.User
//			{
//				Team t1 = new Team();
//				t1.setName("Team 1");
//
//				Team t2 = new Team();
//				t2.setName("Team 2");
//
//				User u1 = new User();
//				u1.setName("User 1");
//
//				User u2 = new User();
//				u2.setName("User 2");
//
//				// Team 중심 연결
//				t1.setUsers(List.of(u1, u2));
//				t2.setUsers(List.of(u2));
//
//				// Team 만 persist
//				em.persist(t1);
//				em.persist(t2);
//
//			}
			
			// #7
			// User Entity 2, Team Entity 2 생성
			// Team 중심 연결
			// persist User 2 개
			// User 만 2 건 insert
//			{
//				Team t1 = new Team();
//				t1.setName("Team 1");
//
//				Team t2 = new Team();
//				t2.setName("Team 2");
//
//				User u1 = new User();
//				u1.setName("User 1");
//
//				User u2 = new User();
//				u2.setName("User 2");
//
//				// Team 중심 연결
//				t1.setUsers(List.of(u1, u2));
//				t2.setUsers(List.of(u2));
//
//				// User 만 persist
//				em.persist(u1);
//				em.persist(u2);
//				
//				/* 실행 결과
//				 * Hibernate: insert into users (name) values (?)
//					Hibernate: insert into users (name) values (?)
//				 */
//
//			}
			
			// #8
			// User Entity 2, Team Entity 2 생성
			// User 중심 연결
			// persist User 2 개
			// Non Owner Entity를 persist할 때 Owner Entity가 연결되어 있어서 무시
			// #6 Team 대비 오류 발생 X
//			{
//				Team t1 = new Team();
//				t1.setName("Team 1");
//
//				Team t2 = new Team();
//				t2.setName("Team 2");
//
//				User u1 = new User();
//				u1.setName("User 1");
//
//				User u2 = new User();
//				u2.setName("User 2");
//
//				// User 중심 연결
//				u1.setTeams(List.of(t1, t2));
//				u2.setTeams(List.of(t2));
//
//				// User 만 persist
//				em.persist(u1);
//				em.persist(u2);
//
//				/*
//				 * 실행 결과 
//					Hibernate: insert into users (name) values (?)
//					Hibernate: insert into users (name) values (?)
//				 */
//
//			}
			
			// #9
			// #6 오류 대응
			// Team에 CascadeType PERSIST 추가
			// User Entity 2, Team Entity 2 생성
			// Team 중심 연결
			// persist Team 2 개
			// Team
			{
				Team t1 = new Team();
				t1.setName("Team 1");

				Team t2 = new Team();
				t2.setName("Team 2");

				User u1 = new User();
				u1.setName("User 1");

				User u2 = new User();
				u2.setName("User 2");

				// Team 중심 연결
				t1.setUsers(List.of(u1, u2));
				t2.setUsers(List.of(u2));

				// Team 만 persist
				em.persist(t1);
				em.persist(t2);
				
				/*
				 * Hibernate: insert into teams (name) values (?)
					Hibernate: insert into users (name) values (?)
					Hibernate: insert into users (name) values (?)
					Hibernate: insert into teams (name) values (?)
					Hibernate: insert into teams_users (team_id,user_id) values (?,?)
					Hibernate: insert into teams_users (team_id,user_id) values (?,?)
					Hibernate: insert into teams_users (team_id,user_id) values (?,?)
				 */

			}
			
			// #10
			// #8 대응 (오류나지는 않았지만, 혹시 User 외 데이터 처리가 가능한지 확인)
			// User에 CascadeType PERSIST 추가, Team에서는 CascadeType PERSIST 제외
			// User Entity 2, Team Entity 2 생성
			// User 중심 연결
			// persist User 2 개
			// Non Owner Entity를 persist할 때 CascadeType이 PERSIST인 경우, 개별 관계를 맺는 Entity는 persist가 되는데
			// @ManyToMany에 대응하는 Join Table에는 처리 X
//			{
//				Team t1 = new Team();
//				t1.setName("Team 1");
//
//				Team t2 = new Team();
//				t2.setName("Team 2");
//
//				User u1 = new User();
//				u1.setName("User 1");
//
//				User u2 = new User();
//				u2.setName("User 2");
//
//				// User 중심 연결
//				u1.setTeams(List.of(t1, t2));
//				u2.setTeams(List.of(t2));
//
//				// User 만 persist
//				em.persist(u1);
//				em.persist(u2);
//
//				/*
//				 * 실행 결과 
//					Hibernate: insert into users (name) values (?)
//					Hibernate: insert into teams (name) values (?)
//					Hibernate: insert into teams (name) values (?)
//					Hibernate: insert into users (name) values (?)
//				 */
//
//			}
			
			em.getTransaction().commit(); // update 수행
			
		} finally {
			em.close();
		}
		
	}

}

```

### find

### src/main/java/com/mycom/myapp

### entity/Team.java

```java
package com.mycom.myapp.entity;

import java.util.List;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.JoinTable;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.Table;

// Owner Entity
@Entity
@Table(name = "teams")
public class Team {
	
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private int id;
	
	private String name;
	
	// #1 ~ #8, #10
	// #A, #C
	@ManyToMany
	@JoinTable(
			name = "teams_users",  // 다대다 두 entity를 연결해주는 중간 테이블 이름
			joinColumns = @JoinColumn(name = "team_id"), // 중간 테이블에 생길 현재(Owner) entity를 가리키는 컬럼
			inverseJoinColumns = @JoinColumn(name = "user_id") // 중간 테이블에 생길 상대(Non Owner) entity를 가리키는 컬럼
	)
	private List<User> users;
	
	// #9
//	@ManyToMany(cascade = CascadeType.PERSIST)
//	@JoinTable(
//			name = "teams_users",  // 다대다 두 entity를 연결해주는 중간 테이블 이름
//			joinColumns = @JoinColumn(name = "team_id"), // 중간 테이블에 생길 현재(Owner) entity를 가리키는 컬럼
//			inverseJoinColumns = @JoinColumn(name = "user_id") // 중간 테이블에 생길 상대(Non Owner) entity를 가리키는 컬럼
//	)
//	private List<User> users;
	
	// #B
//	@ManyToMany(fetch = FetchType.EAGER)
//	@JoinTable(
//			name = "teams_users",  // 다대다 두 entity를 연결해주는 중간 테이블 이름
//			joinColumns = @JoinColumn(name = "team_id"), // 중간 테이블에 생길 현재(Owner) entity를 가리키는 컬럼
//			inverseJoinColumns = @JoinColumn(name = "user_id") // 중간 테이블에 생길 상대(Non Owner) entity를 가리키는 컬럼
//	)
//	private List<User> users;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public List<User> getUsers() {
		return users;
	}

	public void setUsers(List<User> users) {
		this.users = users;
	}

	@Override
	public String toString() {
		return "Team [id=" + id + ", name=" + name + "]";
	}

}

```

### entity/User.java

```java
package com.mycom.myapp.entity;

import java.util.List;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.Table;

// Non Owner Entity
@Entity
@Table(name = "users")
public class User {
	
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private int id;
	
	private String name;
	
	// #1 ~ #9
	// #A, #B, #C
	@ManyToMany(mappedBy = "users")
	private List<Team> teams;
	
	// #10
//	@ManyToMany(mappedBy = "users", cascade = CascadeType.PERSIST)
//	private List<Team> teams;
	
	// #D
//	@ManyToMany(mappedBy = "users", fetch = FetchType.EAGER)
//	private List<Team> teams;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public List<Team> getTeams() {
		return teams;
	}

	public void setTeams(List<Team> teams) {
		this.teams = teams;
	}

	@Override
	public String toString() {
		return "User [id=" + id + ", name=" + name + "]";
	}
	
}
```

### Test2.java

```java
package com.mycom.myapp;

import java.util.HashMap;
import java.util.Map;

import org.hibernate.jpa.HibernatePersistenceProvider;

import com.mycom.myapp.config.MyPersistenceUnitInfo;
import com.mycom.myapp.entity.User;

import jakarta.persistence.EntityManager;
import jakarta.persistence.EntityManagerFactory;

public class Test2 {

	public static void main(String[] args) {

		Map<String, String> props = new HashMap<>();
		props.put("hibernate.show_sql", "true");	// sql 명령문을 확인할 수 있다.
//		props.put("hibernate.hbm2ddl.auto", "create");	// 속성에 create, update 등이 올 수 있다.
		
		EntityManagerFactory emf = new HibernatePersistenceProvider().createContainerEntityManagerFactory(new MyPersistenceUnitInfo(), props);
		EntityManager em = emf.createEntityManager();
		
		try {
			em.getTransaction().begin();
			
			// #A
			// Team find()
			// Team 자신의 것만 가져온다.
			// @ManyToMany FetchType가 LAZY
//			{
//				Team t1 = em.find(Team.class, 1);
//				System.out.println(t1);
//				
//				/* 실행 결과 (try 제외) 
//				 * Hibernate: select t1_0.id,t1_0.name from teams t1_0 where t1_0.id=?
//					Team [id=1, name=Team 1]
//				 */
//				
//				try {
//					Thread.sleep(5000);
//				}catch (Exception e) {
//					e.printStackTrace();
//				}
//				
//				// User가 필요할 때 다시 가져온다.( join table과 users join )
//				System.out.println(t1.getUsers());
//				
//				/* 실행 결과
//				 * Hibernate: select t1_0.id,t1_0.name from teams t1_0 where t1_0.id=?
//					Team [id=1, name=Team 1]
//					Hibernate: select u1_0.team_id,u1_1.id,u1_1.name from teams_users u1_0 join users u1_1 on u1_1.id=u1_0.user_id where u1_0.team_id=?
//					[User [id=1, name=User 1], User [id=2, name=User 2]]
//				 */
//				
//			}
			
			// #B
			// Team FetchType 을 EAGER로 변경
			// Team find()
			// join하여 Team, User 함께 가져온다.
//			{
//				Team t1 = em.find(Team.class, 1);
//				System.out.println(t1);
//
//				/*
//				 * 실행 결과 (try 제외) 
//					Hibernate: select t1_0.id,t1_0.name,u1_0.team_id,u1_1.id,u1_1.name from teams t1_0 left join teams_users u1_0 on t1_0.id=u1_0.team_id left join users u1_1 on u1_1.id=u1_0.user_id where t1_0.id=?
//					Team [id=1, name=Team 1]
//				 */
//
//				try {
//					Thread.sleep(5000);
//				} catch (Exception e) {
//					e.printStackTrace();
//				}
//
//				// User가 필요할 때 다시 가져오지 않는다. sql 수행 X
//				System.out.println(t1.getUsers());
//
//				/*
//				 * 실행 결과 
//					Hibernate: select t1_0.id,t1_0.name,u1_0.team_id,u1_1.id,u1_1.name from teams t1_0 left join teams_users u1_0 on t1_0.id=u1_0.team_id left join users u1_1 on u1_1.id=u1_0.user_id where t1_0.id=?
//					Team [id=1, name=Team 1]
//					[User [id=1, name=User 1], User [id=2, name=User 2]]
//				 */
//
//			}
			
			// #C
			// User find()
			// User 자신의 것만 가져온다.
			// @ManyToMany FetchType가 LAZY
//			{
//				User u1 = em.find(User.class, 1);
//				System.out.println(u1);
//
//				/*
//				 * 실행 결과 (try 제외) 
//					Hibernate: select u1_0.id,u1_0.name from users u1_0 where u1_0.id=?
//					User [id=1, name=User 1]
//				 */
//
//				try {
//					Thread.sleep(5000);
//				} catch (Exception e) {
//					e.printStackTrace();
//				}
//
//				// Team가 필요할 때 다시 가져온다.( join table과 teams join )
//				// 만약 Team의 FatchType이 EAGER이면 Team과 연관된 User를 가져오기 위한 SQL 하나 더 수행된다.
//				System.out.println(u1.getTeams());
//
//				/*
//				 * 실행 결과 
//					Hibernate: select u1_0.id,u1_0.name from users u1_0 where u1_0.id=?
//					User [id=1, name=User 1]
//					Hibernate: select t1_0.user_id,t1_1.id,t1_1.name from teams_users t1_0 join teams t1_1 on t1_1.id=t1_0.team_id where t1_0.user_id=?
//					[Team [id=1, name=Team 1]]
//				 */
//
//			}
			
			// #D
			// User FetchType 을 EAGER로 변경
			// User find()
			// join 으로 User, Team 모두 가져온다.
			{
				User u1 = em.find(User.class, 1);
				System.out.println(u1);

				/*
				 * 실행 결과 (try 제외) 
					Hibernate: select u1_0.id,u1_0.name,t1_0.user_id,t1_1.id,t1_1.name from users u1_0 left join teams_users t1_0 on u1_0.id=t1_0.user_id left join teams t1_1 on t1_1.id=t1_0.team_id where u1_0.id=?
					User [id=1, name=User 1]
				 */

				try {
					Thread.sleep(5000);
				} catch (Exception e) {
					e.printStackTrace();
				}

				// Team가 필요할 때 다시 가져오지 않는다.
				System.out.println(u1.getTeams());

				/*
				 * 실행 결과 
					Hibernate: select u1_0.id,u1_0.name,t1_0.user_id,t1_1.id,t1_1.name from users u1_0 left join teams_users t1_0 on u1_0.id=t1_0.user_id left join teams t1_1 on t1_1.id=t1_0.team_id where u1_0.id=?
					User [id=1, name=User 1]
					[Team [id=1, name=Team 1]]
				 */

			}
			
			em.getTransaction().commit(); // update 수행
		} finally {
			em.close();
		}
		
	}

}
```

### 기존 Post 에 새 Comment 추가

### src/main/java/com/mycom/myapp

### entity/Team.java

```java
package com.mycom.myapp.entity;

import java.util.List;
import java.util.Set;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.JoinTable;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.Table;

// Owner Entity
@Entity
@Table(name = "teams")
public class Team {
	
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private int id;
	
	private String name;
	
	// #1 ~ #8, #10
	// #A, #C
//	@ManyToMany
//	@JoinTable(
//			name = "teams_users",  // 다대다 두 entity를 연결해주는 중간 테이블 이름
//			joinColumns = @JoinColumn(name = "team_id"), // 중간 테이블에 생길 현재(Owner) entity를 가리키는 컬럼
//			inverseJoinColumns = @JoinColumn(name = "user_id") // 중간 테이블에 생길 상대(Non Owner) entity를 가리키는 컬럼
//	)
//	private List<User> users;
	
	// #나
	@ManyToMany
	@JoinTable(
			name = "teams_users",  // 다대다 두 entity를 연결해주는 중간 테이블 이름
			joinColumns = @JoinColumn(name = "team_id"), // 중간 테이블에 생길 현재(Owner) entity를 가리키는 컬럼
			inverseJoinColumns = @JoinColumn(name = "user_id") // 중간 테이블에 생길 상대(Non Owner) entity를 가리키는 컬럼
	)
	private Set<User> users;
	
	// #9
//	@ManyToMany(cascade = CascadeType.PERSIST)
//	@JoinTable(
//			name = "teams_users",  // 다대다 두 entity를 연결해주는 중간 테이블 이름
//			joinColumns = @JoinColumn(name = "team_id"), // 중간 테이블에 생길 현재(Owner) entity를 가리키는 컬럼
//			inverseJoinColumns = @JoinColumn(name = "user_id") // 중간 테이블에 생길 상대(Non Owner) entity를 가리키는 컬럼
//	)
//	private List<User> users;
	
	// #B
//	@ManyToMany(fetch = FetchType.EAGER)
//	@JoinTable(
//			name = "teams_users",  // 다대다 두 entity를 연결해주는 중간 테이블 이름
//			joinColumns = @JoinColumn(name = "team_id"), // 중간 테이블에 생길 현재(Owner) entity를 가리키는 컬럼
//			inverseJoinColumns = @JoinColumn(name = "user_id") // 중간 테이블에 생길 상대(Non Owner) entity를 가리키는 컬럼
//	)
//	private List<User> users;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

//	public List<User> getUsers() {
//		return users;
//	}
//
//	public void setUsers(List<User> users) {
//		this.users = users;
//	}
	
	// #나
	public Set<User> getUsers() {
		return users;
	}

	public void setUsers(Set<User> users) {
		this.users = users;
	}

	@Override
	public String toString() {
		return "Team [id=" + id + ", name=" + name + "]";
	}

}
```

### entity/User.java

```java
package com.mycom.myapp.entity;

import java.util.List;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.Table;

// Non Owner Entity
@Entity
@Table(name = "users")
public class User {
	
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private int id;
	
	private String name;
	
	// #1 ~ #9
	// #A, #B, #C
	@ManyToMany(mappedBy = "users")
	private List<Team> teams;
	
	// #10
//	@ManyToMany(mappedBy = "users", cascade = CascadeType.PERSIST)
//	private List<Team> teams;
	
	// #D
//	@ManyToMany(mappedBy = "users", fetch = FetchType.EAGER)
//	private List<Team> teams;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public List<Team> getTeams() {
		return teams;
	}

	public void setTeams(List<Team> teams) {
		this.teams = teams;
	}

	@Override
	public String toString() {
		return "User [id=" + id + ", name=" + name + "]";
	}
	
}
```

### Test3.java

```java
package com.mycom.myapp;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import org.hibernate.jpa.HibernatePersistenceProvider;

import com.mycom.myapp.config.MyPersistenceUnitInfo;
import com.mycom.myapp.entity.Team;
import com.mycom.myapp.entity.User;

import jakarta.persistence.EntityManager;
import jakarta.persistence.EntityManagerFactory;

public class Test3 {

	public static void main(String[] args) {

		Map<String, String> props = new HashMap<>();
		props.put("hibernate.show_sql", "true");	// sql 명령문을 확인할 수 있다.
//		props.put("hibernate.hbm2ddl.auto", "create");	// 속성에 create, update 등이 올 수 있다.
		
		EntityManagerFactory emf = new HibernatePersistenceProvider().createContainerEntityManagerFactory(new MyPersistenceUnitInfo(), props);
		EntityManager em = emf.createEntityManager();
		
		try {
			em.getTransaction().begin();
			
			// #가
			// Team 의 users : List<User>
//			{
//				Team t2 = em.find(Team.class, 2);
//				User u1 = em.find(User.class, 1);
//
//				t2.getUsers().add(u1);
//
//				em.persist(u1);
//
//				/*
//				 *Hibernate: select t1_0.id,t1_0.name from teams t1_0 where t1_0.id=?
//				Hibernate: select u1_0.id,u1_0.name from users u1_0 where u1_0.id=?
//				Hibernate: select u1_0.team_id,u1_1.id,u1_1.name from teams_users u1_0 join users u1_1 on u1_1.id=u1_0.user_id where u1_0.team_id=?
//				Hibernate: delete from teams_users where team_id=?
//				Hibernate: insert into teams_users (team_id,user_id) values (?,?)
//				Hibernate: insert into teams_users (team_id,user_id) values (?,?)
//				 */
//			}

			// #나
			// Team 의 users : Set<User> : 다른 Main 오류 발생 하나 무시
//			{
//				Team t2 = em.find(Team.class, 2);
//				User u1 = em.find(User.class, 1);
//
//				t2.getUsers().add(u1);
//
//				em.persist(u1);
//
//				/*
//				 * Hibernate: select t1_0.id,t1_0.name from teams t1_0 where t1_0.id=?
//					Hibernate: select u1_0.id,u1_0.name from users u1_0 where u1_0.id=?
//					Hibernate: select u1_0.team_id,u1_1.id,u1_1.name from teams_users u1_0 join users u1_1 on u1_1.id=u1_0.user_id where u1_0.team_id=?
//					Hibernate: insert into teams_users (team_id,user_id) values (?,?)
//				 */
//			}
			
			// #다
			// 추가 데이터 생성 ( 그냥 mysql 에서 처리하는 게 낫다. )
			// Team users : Set<User>
			// Set 은 select 순서대로 처리되지 X
//          {
//              Team t3 = new Team();
//              t3.setName("team 3");
//              
//              User u3 = new User();
//              u3.setName("User 3");
//              
//              User u4 = new User();
//              u4.setName("User 4");
//              
//              
//              User u5 = new User();
//              u5.setName("User 5");
//              
//              User u6 = new User();
//              u6.setName("User 6");
//              
//              t3.setUsers(Set.of(u3, u4, u5, u6));
//
//              em.persist(u3);
//              em.persist(u4);
//              em.persist(u5);
//              em.persist(u6);
//              em.persist(t3);
//              
//              
//				/*
//				Hibernate: insert into users (name) values (?)
//				Hibernate: insert into users (name) values (?)
//				Hibernate: insert into users (name) values (?)
//				Hibernate: insert into users (name) values (?)
//				Hibernate: insert into teams (name) values (?)
//				Hibernate: insert into teams_users (team_id,user_id) values (?,?)
//				Hibernate: insert into teams_users (team_id,user_id) values (?,?)
//				Hibernate: insert into teams_users (team_id,user_id) values (?,?)
//				Hibernate: insert into teams_users (team_id,user_id) values (?,?)         
//				 */
//          }

			// #라
			// Team users 를 List -> Set 으로 변경, 다른 파일 오류 잠시 무시
			// Set 은 select 순서대로 처리되지 X
			// Team 의 user 에 @OrderBy() 를 이용해서 정렬
			{
				Team t3 = em.find(Team.class, 3);
				System.out.println(t3.getUsers());

				/*
				 * 테이블의 select 순서와 다르다. 
				 * Hibernate: select t1_0.id,t1_0.name from teams t1_0 where t1_0.id=?
					Hibernate: select u1_0.team_id,u1_1.id,u1_1.name from teams_users u1_0 join users u1_1 on u1_1.id=u1_0.user_id where u1_0.team_id=?
					[User [id=4, name=User 4], User [id=5, name=User 5], User [id=6, name=User 6], User [id=3, name=User 3]]
				 */

				/*
				 * @OrderBy("id desc") Hibernate: select t1_0.id,t1_0.name from teams t1_0 where
				 * t1_0.id=? Hibernate: select u1_0.team_id,u1_1.id,u1_1.name from teams_users
				 * u1_0 join users u1_1 on u1_1.id=u1_0.user_id where u1_0.team_id=? order by
				 * u1_0.user_id desc [User [id=6, name=User 6], User [id=5, name=User 5], User
				 * [id=4, name=User 4], User [id=3, name=User 3]]
				 * 
				 * @OrderBy("id") Hibernate: select t1_0.id,t1_0.name from teams t1_0 where
				 * t1_0.id=? Hibernate: select u1_0.team_id,u1_1.id,u1_1.name from teams_users
				 * u1_0 join users u1_1 on u1_1.id=u1_0.user_id where u1_0.team_id=? order by
				 * u1_0.user_id [User [id=3, name=User 3], User [id=4, name=User 4], User [id=5,
				 * name=User 5], User [id=6, name=User 6]]
				 */
			}

			em.getTransaction().commit(); // update 수행
		} finally {
			em.close();
		}
		
	}

}
```