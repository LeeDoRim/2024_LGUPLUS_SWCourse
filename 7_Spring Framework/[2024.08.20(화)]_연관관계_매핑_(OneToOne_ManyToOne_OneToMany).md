# [2024.08.20(화)] 연관관계 매핑(OneToOne/ManyToOne/OneToMany)


# JPABasic_6_OneToOne_BI 프로젝트

### src/main/java/com/mycom/myapp

### entity/Person.java

```java
package com.mycom.myapp.entity;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToOne;

// Person 1명당 Passport 1개를 가진다.
@Entity
public class Person {
	
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private int id;
	
	private String name;
	
	// #1 #3
	@OneToOne
	// JoinColumn을 가진 Entity가 관계에서 Ownership을 가진다.
	@JoinColumn(name = "passport") // passport 컬럼명 명시적으로 지정
	
	// #2
//	@OneToOne(cascade = CascadeType.PERSIST) // Person을 persist할 때 passport도 같이 persist한다.
//	@JoinColumn(name = "passport") // passport 컬럼명 명시적으로 지정
	
	// #C (Test2)
//	@OneToOne(fetch = FetchType.LAZY)
//	@JoinColumn(name = "passport")
	private Passport passport;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Passport getPassport() {
		return passport;
	}

	public void setPassport(Passport passport) {
		this.passport = passport;
	}

	// #E
//	@Override
//	public String toString() {
//		return "Person [id=" + id + ", name=" + name + ", passport=" + passport + "]";
//	}
	
	// #C 테스트에서 아래의 코드 중 passport 제외
	// toString에  passport를 사용하고 있다.
	@Override
	public String toString() {
		return "Person [id=" + id + ", name=" + name + "]";
	}
	
}
```

### entity/Passport.java

```java
package com.mycom.myapp.entity;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.OneToOne;

@Entity
public class Passport {
	
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private int id;
	
	private String number;

	// @OneToOne 추가되어도 (mappedBy = "passport")이 있으면 Passport 테이블에 Person 칼럼 만들어지지 X
	// (mappedBy = "passport") 의미가 Non Owner Entity 성격
	
	// #1, #2, #A, #B, #C, #E
//	@OneToOne(mappedBy = "passport") // OneToOne 관계의 Owner Entity Person에서 @JoinColumn field 이름
	
	// #3
	// @OneToOne(mappedBy = "passport", cascade = CascadeType.PERSIST) // OneToOne 관계의 Owner Entity Person에서 @JoinColumn field 이름
	
	// #D
	@OneToOne(mappedBy = "passport", fetch = FetchType.LAZY)
	private Person person;
	
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getNumber() {
		return number;
	}

	public void setNumber(String number) {
		this.number = number;
	}
	
	public Person getPerson() {
		return person;
	}

	public void setPerson(Person person) {
		this.person = person;
	}

	// #E
//	@Override
//	public String toString() {
//		return "Passport [id=" + id + ", number=" + number + ", person=" + person + "]";
//	}
	
	@Override
	public String toString() {
		return "Passport [id=" + id + ", number=" + number + "]";
	}
	
}
```

### Test2.java

```java
package com.mycom.myapp;

import java.util.HashMap;
import java.util.Map;

import org.hibernate.jpa.HibernatePersistenceProvider;

import com.mycom.myapp.config.MyPersistenceUnitInfo;
import com.mycom.myapp.entity.Passport;
import com.mycom.myapp.entity.Person;

import jakarta.persistence.CascadeType;
import jakarta.persistence.EntityManager;
import jakarta.persistence.EntityManagerFactory;
import jakarta.persistence.OneToOne;

// Key 설정
public class Test2 {

	public static void main(String[] args) {

		Map<String, String> props = new HashMap<>();
		props.put("hibernate.show_sql", "true");	// sql 명령문을 확인할 수 있다.
//		props.put("hibernate.hbm2ddl.auto", "create");	// 속성에 create, update 등이 올 수 있다.
		
		EntityManagerFactory emf = new HibernatePersistenceProvider().createContainerEntityManagerFactory(new MyPersistenceUnitInfo(), props);
		EntityManager em = emf.createEntityManager();
		
		try {
			em.getTransaction().begin();
			
			// #A
			// Passport find()
			// join 수행, Person 함께 가져온다.
			// @OneToOne의 default FetchType이 EAGER
//			{
//				Passport passport = em.find(Passport.class, 1);
//				System.out.println(passport);
//				
//				try {
//					Thread.sleep(5000);
//				} catch (Exception e) {
//					e.printStackTrace();
//				}
//				
//				// passport를 이용해서 person entity를 사용하면 sql 다시 수행 X
//				System.out.println(passport.getPerson());
//			}
			
			// #B
			// Person find()
			// join 수행, Person 함께 가져온다.
			// @OneToOne의 default FetchType이 EAGER
//			{
//				Person person = em.find(Person.class, 1);
//				System.out.println(person);
//
//				try {
//					Thread.sleep(5000);
//				} catch (Exception e) {
//					e.printStackTrace();
//				}
//
//				// person를 이용해서 passport entity를 사용하면 sql 다시 수행 X
//				System.out.println(person.getPassport());
//			}
			
			// #C
			// Person find()
			// Person fetch LAZY 설정
			// join 수행, Person만 가져온다.
//			{
//				Person person = em.find(Person.class, 1);
//				System.out.println(person);
//
//				try {
//					Thread.sleep(5000);
//				} catch (Exception e) {
//					e.printStackTrace();
//				}
//
//				// person를 이용해서 passport entity를 사용하면 sql 다시 수행 (join)
//				/*
//				Hibernate: select p1_0.id,p1_0.name,p1_0.passport from Person p1_0 where p1_0.id=?
//				Person [id=1, name=홍길동]
//				Hibernate: select p1_0.id,p1_0.number,p2_0.id,p2_0.name from Passport p1_0 left join Person p2_0 on p1_0.id=p2_0.passport where p1_0.id=?
//				Passport [id=1, number=kor123]
//				*/
//				System.out.println(person.getPassport());
//			}
			
			// #D
			// Passport find()
			// Passport fetch LAZY 변경, Person fetch EAGER로 원복
			// Passport를 위한 select 1건 수행 + Person 과의 join 1건 수행 : 총 2 건의 sql 수행
			// 연관관계에서 fetch를 LAZY로 변경해도 join sql이 수행되는 경우 발생
			// mappedBy에 의해 Non Owner Entity인 경우, 해당 테이블에 Owner Entity에 대한 컬럼이 X
			// -> Passport 1건으로부터 이후 연관된 Person을 찾을 방법 X
			// -> LAZY 정책을 수행하기 위해서는 미리 Passport와 연관된 Person을 찾아서 준비(궁여지책)
			// LAZY에 대한 JPA 구현체의 대응 : Proxy 생성 <- null (person) 어렵다.
//			{
//				Passport passport = em.find(Passport.class, 1);
//				System.out.println(passport);
//				
//				/*
//				 * 실행 결과 (try 제외)
//				 *  Hibernate: select p1_0.id,p1_0.number from Passport p1_0 where p1_0.id=?
//					Hibernate: select p1_0.id,p1_0.name,p2_0.id,p2_0.number from Person p1_0 left join Passport p2_0 on p2_0.id=p1_0.passport where p1_0.passport=?
//					Passport [id=1, number=kor123]
//				 */
//
//				try {
//					Thread.sleep(5000);
//				} catch (Exception e) {
//					e.printStackTrace();
//				}
//
//				// passport를 이용해서 person entity를 사용하면 sql 다시 수행 X (위 미리 선 수행된 join에 의해 가능)
//				System.out.println(passport.getPerson());
//				
//				/*
//				 * 실행결과
//				 * Hibernate: select p1_0.id,p1_0.number from Passport p1_0 where p1_0.id=?
//					Hibernate: select p1_0.id,p1_0.name,p2_0.id,p2_0.number from Person p1_0 left join Passport p2_0 on p2_0.id=p1_0.passport where p1_0.passport=?
//					Passport [id=1, number=kor123]
//					Person [id=1, name=홍길동]
//				 */
//			}
			
			// #E
			// Passport find()
			// Person의 toString()에서 Passport 출력
			// Passport의 toString()에서 Person 출력
			// StackOverflowError 발생 ( toString() 의 순환구조 )
			// lombok (@Data, @ToString 주의!! )
			// 
			{
				Passport passport = em.find(Passport.class, 1);
				System.out.println(passport);
			}
			
			em.getTransaction().commit(); // update 수행
		} finally {
			em.close();
		}
			
	}

}
```

# JPA OneToOne Relationship

### 1. **기본 개념**

- **1:1 관계**: 한 엔티티가 다른 엔티티와 정확히 하나의 관계를 가지는 경우를 의미합니다. 예를 들어, `User`와 `Profile` 간의 관계에서, 한 사용자는 하나의 프로필을 가지며, 그 프로필은 오직 그 사용자와만 연결됩니다.
- **연관관계의 주인**: JPA에서는 두 테이블 간의 관계에서 외래 키를 관리하는 쪽을 연관관계의 주인(owner)이라고 합니다. 연관관계의 주인은 `mappedBy` 속성을 사용하지 않으며, 외래 키를 직접 관리합니다.

### 2. **애노테이션 사용**

- `@OneToOne`: 1:1 관계를 나타내는 기본 애노테이션입니다.
- `@JoinColumn`: 외래 키를 명시적으로 지정하기 위해 사용합니다. 이 애노테이션을 통해 외래 키의 이름과 제약 조건 등을 설정할 수 있습니다.
- `mappedBy`: 양방향 관계에서 연관관계의 주인이 아닌 쪽에서 사용됩니다.

### 3. **예시**

### 3.1. 단방향 `@OneToOne` 매핑

```java
java코드 복사
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @OneToOne
    @JoinColumn(name = "profile_id")
    private Profile profile;

    // getters and setters
}

@Entity
public class Profile {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String bio;

    // getters and setters
}

```

- **User** 엔티티는 `Profile` 엔티티와 1:1 관계를 가지며, `profile_id`라는 외래 키를 통해 연결됩니다.
- 여기서 `@JoinColumn(name = "profile_id")`는 `User` 엔티티에서 외래 키로 `Profile` 엔티티의 `id`를 참조하도록 합니다.

### 3.2. 양방향 `@OneToOne` 매핑

```java
java코드 복사
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @OneToOne(mappedBy = "user")
    private Profile profile;

    // getters and setters
}

@Entity
public class Profile {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String bio;

    @OneToOne
    @JoinColumn(name = "user_id")
    private User user;

    // getters and setters
}

```

- 이 예제에서 `User`와 `Profile`은 서로 양방향 관계를 가집니다.
- `Profile` 엔티티가 외래 키 `user_id`를 가지고 있으며, 이 외래 키는 `User` 엔티티의 `id`를 참조합니다. 따라서 `Profile` 엔티티가 연관관계의 주인입니다.
- `User` 엔티티의 `profile` 필드에서는 `mappedBy` 속성을 사용하여 연관관계의 주인이 `Profile` 엔티티의 `user` 필드임을 지정합니다.

### 4. **지연 로딩과 즉시 로딩**

- **지연 로딩(Lazy Loading)**: 연관된 엔티티를 실제로 사용할 때 로딩합니다. 이를 통해 초기 로딩 시 성능을 향상시킬 수 있습니다. `@OneToOne(fetch = FetchType.LAZY)`로 지정할 수 있습니다.
- **즉시 로딩(Eager Loading)**: 엔티티가 로드될 때 연관된 엔티티도 함께 로드합니다. `@OneToOne(fetch = FetchType.EAGER)`가 기본값입니다.

### 5. **Cascade 옵션**

- **Cascade**: 부모 엔티티에서 자식 엔티티에 대해 특정 작업(저장, 삭제 등)을 자동으로 전파할 수 있습니다. 예를 들어, `CascadeType.ALL`로 설정하면 부모 엔티티가 저장될 때 자식 엔티티도 자동으로 저장됩니다.

```java
java코드 복사
@OneToOne(cascade = CascadeType.ALL)
private Profile profile;

```

### 6. **고려사항**

- **데이터베이스 설계**: 1:1 관계를 데이터베이스에 반영할 때, 외래 키가 있는 테이블에 대한 고려가 필요합니다. 일반적으로 외래 키는 더 자주 조회되는 테이블에 두는 것이 좋습니다.
- **지연 로딩**: 지연 로딩 시 프록시 객체가 생성되므로, 프록시 초기화 관련 예외가 발생하지 않도록 주의해야 합니다.

### 7. **요약**

- `@OneToOne`은 두 엔티티 간의 1:1 관계를 정의합니다.
- `@JoinColumn`으로 외래 키를 명시적으로 지정할 수 있으며, `mappedBy`를 통해 양방향 관계에서의 주인을 설정할 수 있습니다.
- 지연 로딩과 즉시 로딩을 선택할 수 있으며, `Cascade` 옵션으로 연관 엔티티에 대한 작업을 전파할 수 있습니다.

# JPABasic_7_ManyToOne 프로젝트 생성

- JPABasic_6_OneToOne_BI 프로젝트 복사하여 JPABasic_7_ManyToOne 프로젝트 생성
- jpa_basic_7 스키마 생성
- entity 패키지에 생성한 클래스 모두 삭제

- ManyToOne은 Ownership을 Many 클래스가 갖는다.
    
    ex) one - post, Many - comment일 경우 comment가 Ownership을 갖는다. 
    
    (FK를 comment가 가진다.)
    
- OneToMany는 Ownership을 One 클래스가 갖는다.
    
    ex) one - post, Many - comment일 경우 post가 Ownership을 갖는다. 
    
    (FK를 post가 가진다.)
    

### src/main/java/com/mycom/myapp

### config/MyPersistenceUnitInfo.java

```java
package com.mycom.myapp.config;

import java.net.URL;
import java.util.List;
import java.util.Properties;

import javax.sql.DataSource;

import com.zaxxer.hikari.HikariDataSource;

import jakarta.persistence.SharedCacheMode;
import jakarta.persistence.ValidationMode;
import jakarta.persistence.spi.ClassTransformer;
import jakarta.persistence.spi.PersistenceUnitInfo;
import jakarta.persistence.spi.PersistenceUnitTransactionType;

// META-INF/persistence.xml 대체
public class MyPersistenceUnitInfo implements PersistenceUnitInfo {

	@Override
	public String getPersistenceUnitName() {
		return "my-pu";
	}

	@Override
	public String getPersistenceProviderClassName() {
		return "org.hibernate.jpa.HibernatePersistenceProvider";
	}

	@Override
	public PersistenceUnitTransactionType getTransactionType() {
		return PersistenceUnitTransactionType.RESOURCE_LOCAL;
	}

	@Override
	public DataSource getJtaDataSource() {
		HikariDataSource dataSource = new HikariDataSource();
		dataSource.setJdbcUrl("jdbc:mysql://localhost:3306/jpa_basic_7");
		dataSource.setUsername("root");
		dataSource.setPassword("root");
		return dataSource;
	}

	@Override
	public DataSource getNonJtaDataSource() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<String> getMappingFileNames() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<URL> getJarFileUrls() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public URL getPersistenceUnitRootUrl() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<String> getManagedClassNames() {
		return List.of("com.mycom.myapp.entity.Post", "com.mycom.myapp.entity.Comment");
	}

	@Override
	public boolean excludeUnlistedClasses() {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public SharedCacheMode getSharedCacheMode() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public ValidationMode getValidationMode() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Properties getProperties() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public String getPersistenceXMLSchemaVersion() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public ClassLoader getClassLoader() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void addTransformer(ClassTransformer transformer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public ClassLoader getNewTempClassLoader() {
		// TODO Auto-generated method stub
		return null;
	}

}
```

### entity/Post.java

```java
package com.mycom.myapp.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;

// Non Owner Entity
@Entity
public class Post {
	
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private int id;
	
	private String title;
	
	private String content;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getTitle() {
		return title;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	@Override
	public String toString() {
		return "Post [id=" + id + ", title=" + title + ", content=" + content + "]";
	}
	
}
```

### entity/Comment.java

```java
package com.mycom.myapp.entity;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToOne;

// Owner Entity
@Entity
public class Comment {

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private int id;

	private String content;

	// #1 ~ #7
//	@ManyToOne
//	private Post post;

	// #8
	@ManyToOne(cascade = CascadeType.PERSIST)
	private Post post;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	public Post getPost() {
		return post;
	}

	public void setPost(Post post) {
		this.post = post;
	}

	@Override
	public String toString() {
		return "Comment [id=" + id + ", content=" + content + "]";
	}

}
```

### Test.java

```java
package com.mycom.myapp;

import java.util.HashMap;
import java.util.Map;

import org.hibernate.jpa.HibernatePersistenceProvider;

import com.mycom.myapp.config.MyPersistenceUnitInfo;
import com.mycom.myapp.entity.Comment;
import com.mycom.myapp.entity.Post;

import jakarta.persistence.EntityManager;
import jakarta.persistence.EntityManagerFactory;

// OneToOne Bi-directional 관계는 Owner Entity 한 쪽에 있을 때 해당 colum이 만들어진다.
// 동등한 Owner Entity인 경우는 양쪽에 다 만들어진다.
public class Test {

	public static void main(String[] args) {

		Map<String, String> props = new HashMap<>();
		props.put("hibernate.show_sql", "true");	// sql 명령문을 확인할 수 있다.
		props.put("hibernate.hbm2ddl.auto", "create");	// 속성에 create, update 등이 올 수 있다.
		
		EntityManagerFactory emf = new HibernatePersistenceProvider().createContainerEntityManagerFactory(new MyPersistenceUnitInfo(), props);
		EntityManager em = emf.createEntityManager();
		
		try {
			em.getTransaction().begin();
			
			// #1 
			// table 생성
			// 2개의 테이블 Post, Comment 만들어진다. Comment 테이블에 post_id FK 컬럼이 만들어 진다.
//			{
//				/*
//				 * Hibernate: create table Comment (id integer not null auto_increment, post_id integer, content varchar(255), primary key (id)) engine=InnoDB
//					Hibernate: create table Post (id integer not null auto_increment, content varchar(255), title varchar(255), primary key (id)) engine=InnoDB
//					Hibernate: alter table Comment add constraint FKqb0rnht649ifuh6gev5lwvx8x foreign key (post_id) references Post (id)
//				 */
//			}
			
			// #2
			// Post Entity만 1개 persist
			// Post insert 1건 정상
//			{
//				Post p = new Post();
//				p.setTitle("Post 1");
//				p.setContent("Post 1 Content");
//				
//				em.persist(p);
//				
//				/*
//				 * Hibernate: insert into Post (content,title) values (?,?)
//				 */
//			}
			
			// #3
			// Comment Entity만 2개 persist
			// Comment insert 2건 정상 (단, 연관관계 column인 post_id는 모두 null)
//			{
//				Comment c1 = new Comment();
//				c1.setContent("Commnet 1 Content");
//				
//				Comment c2 = new Comment();
//				c2.setContent("Commnet 2 Content");
//				
//				em.persist(c1);
//				em.persist(c2);
//
//				/*
//				 *Hibernate: insert into Comment (content,post_id) values (?,?)
//					Hibernate: insert into Comment (content,post_id) values (?,?)
//				 */
//			}
			
			// #4
			// Post 1, Comment 2 생성
			// Post, Comment 모두 연결
			// Post 1 개만 persist
			// Post 1 건 insert 정상 (연결된 연관관계에서 non Owner 관계이므로 )
//			{
//				Post p = new Post();
//				p.setTitle("Post 1");
//				p.setContent("Post 1 Content");
//				
//				Comment c1 = new Comment();
//				c1.setContent("Commnet 1 Content");
//
//				Comment c2 = new Comment();
//				c2.setContent("Commnet 2 Content");
//				
//				c1.setPost(p);
//				c2.setPost(p);
//
//				// Post만 persist
//				em.persist(p);
//
//				/*
//				 * Hibernate: insert into Post (content,title) values (?,?)
//				 */
//			}
			
			// #5
			// Post 1, Comment 2 생성
			// Post, Comment 모두 연결
			// Comment 2 개만 persist
			// 오류 발생
			// org.hibernate.TransientPropertyValueException: object references an unsaved transient instance - save the transient instance before flushing : com.mycom.myapp.entity.Comment.post -> com.mycom.myapp.entity.Post
//			{
//				Post p = new Post();
//				p.setTitle("Post 1");
//				p.setContent("Post 1 Content");
//
//				Comment c1 = new Comment();
//				c1.setContent("Commnet 1 Content");
//
//				Comment c2 = new Comment();
//				c2.setContent("Commnet 2 Content");
//
//				// 연결
//				c1.setPost(p);
//				c2.setPost(p);
//
//				// Comment 만 persist
//				em.persist(c1);
//				em.persist(c2);
//
//			}
			
			// #6
			// Post 1, Comment 2 생성
			// Post, Comment 모두 연결
			// Comment, Post 모두 persist
			// Comment 2 건, Post 1 건 insert 후 Comment 2 건 update
//			{
//				Post p = new Post();
//				p.setTitle("Post 1");
//				p.setContent("Post 1 Content");
//
//				Comment c1 = new Comment();
//				c1.setContent("Commnet 1 Content");
//
//				Comment c2 = new Comment();
//				c2.setContent("Commnet 2 Content");
//
//				// 연결
//				c1.setPost(p);
//				c2.setPost(p);
//
//				// Comment, Post 모두 persist
//				em.persist(c1);
//				em.persist(c2);
//				em.persist(p);  // Post 나중에
//				
//				/*
//				 * Hibernate: insert into Comment (content,post_id) values (?,?)
//					Hibernate: insert into Comment (content,post_id) values (?,?)
//					Hibernate: insert into Post (content,title) values (?,?)
//					Hibernate: update Comment set content=?,post_id=? where id=?
//					Hibernate: update Comment set content=?,post_id=? where id=?
//				 */
//				
//			}
			
			// #7 (#6 대비 post를 나중 persist -> 먼저 persist)
			// Post 1, Comment 2 생성
			// Post, Comment 모두 연결
			// Comment, Post 모두 persist
			// Post 1 건, Comment 2 건 insert
			// FK를 제공하는 Entity 먼저 persist 하는 게 성능 면에서 유리하다.
//			{
//				Post p = new Post();
//				p.setTitle("Post 1");
//				p.setContent("Post 1 Content");
//
//				Comment c1 = new Comment();
//				c1.setContent("Commnet 1 Content");
//
//				Comment c2 = new Comment();
//				c2.setContent("Commnet 2 Content");
//
//				// 연결
//				c1.setPost(p);
//				c2.setPost(p);
//
//				// Comment, Post 모두 persist
//				em.persist(p);	// Post 먼저
//				em.persist(c1);
//				em.persist(c2);
//
//				/*
//				 * Hibernate: insert into Post (content,title) values (?,?)
//					Hibernate: insert into Comment (content,post_id) values (?,?)
//					Hibernate: insert into Comment (content,post_id) values (?,?)
//				 */
//
//			}
			
			// #8 (#6 대비 post를 나중 persist -> 먼저 persist)
			// Post 1, Comment 2 생성
			// Post, Comment 모두 연결
			// Comment 2개만 persist
			// Comment에 CascadeType PERSIST
			// Post 1 건, Comment 2 건 insert
			{
				Post p = new Post();
				p.setTitle("Post 1");
				p.setContent("Post 1 Content");

				Comment c1 = new Comment();
				c1.setContent("Commnet 1 Content");

				Comment c2 = new Comment();
				c2.setContent("Commnet 2 Content");

				// 연결
				c1.setPost(p);
				c2.setPost(p);

				// Comment만 persist
				em.persist(c1);
				em.persist(c2);

				/*
				 * Hibernate: insert into Post (content,title) values (?,?)
					Hibernate: insert into Comment (content,post_id) values (?,?)
					Hibernate: insert into Comment (content,post_id) values (?,?)
				 */

			}
			
			em.getTransaction().commit(); // update 수행
			
		} finally {
			em.close();
		}
			
	}

}
```

### find

### src/main/java/com/mycom/myapp

### entity/Post.java

```java
package com.mycom.myapp.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;

// Non Owner Entity
@Entity
public class Post {
	
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private int id;
	
	private String title;
	
	private String content;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getTitle() {
		return title;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	@Override
	public String toString() {
		return "Post [id=" + id + ", title=" + title + ", content=" + content + "]";
	}
	
}

```

### entity/Comment.java

```java
package com.mycom.myapp.entity;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToOne;

// Owner Entity
@Entity
public class Comment {

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private int id;

	private String content;

	// #1 ~ #7
	// #A, #B
//	@ManyToOne
//	private Post post;

	// #8
//	@ManyToOne(cascade = CascadeType.PERSIST)
//	private Post post;
	
	// #C
	@ManyToOne(fetch = FetchType.LAZY)
	private Post post;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	public Post getPost() {
		return post;
	}

	public void setPost(Post post) {
		this.post = post;
	}

	@Override
	public String toString() {
		return "Comment [id=" + id + ", content=" + content + "]";
	}

}

```

### Test2.java

```java
package com.mycom.myapp;

import java.util.HashMap;
import java.util.Map;

import org.hibernate.jpa.HibernatePersistenceProvider;

import com.mycom.myapp.config.MyPersistenceUnitInfo;
import com.mycom.myapp.entity.Comment;

import jakarta.persistence.EntityManager;
import jakarta.persistence.EntityManagerFactory;

public class Test2 {

	public static void main(String[] args) {

		Map<String, String> props = new HashMap<>();
		props.put("hibernate.show_sql", "true");	// sql 명령문을 확인할 수 있다.
//		props.put("hibernate.hbm2ddl.auto", "create");	// 속성에 create, update 등이 올 수 있다.
		
		EntityManagerFactory emf = new HibernatePersistenceProvider().createContainerEntityManagerFactory(new MyPersistenceUnitInfo(), props);
		EntityManager em = emf.createEntityManager();
		
		try {
			em.getTransaction().begin();
			
			// #A
			// Post 1 건 find()
//			{
//				Post p = em.find(Post.class, 1);
//				System.out.println(p);
//				
//				/* 실행결과
//				 * Hibernate: select p1_0.id,p1_0.content,p1_0.title from Post p1_0 where p1_0.id=?
//					Post [id=1, title=Post 1, content=Post 1 Content]
//				 */
//				
//			}
			
			// #B
			// Comment 1 건 find()
			// join으로 연관된 Post 함께 select
			// @ManyToOne 의 FetchType이 EAGER
//			{
//				Comment c1 = em.find(Comment.class, 1);
//				System.out.println(c1);
//
//				/* 실행결과 (try x)
//				 * Hibernate: select c1_0.id,c1_0.content,p1_0.id,p1_0.content,p1_0.title from Comment c1_0 left join Post p1_0 on p1_0.id=c1_0.post_id where c1_0.id=?
//					Comment [id=1, content=Commnet 1 Content]
//				 */
//				
//				try {
//					Thread.sleep(5000);
//				} catch (Exception e) {
//					e.printStackTrace();
//				}
//				
//				// Comment와 연관된 Post를 가져올 때 다시 sql 수행 (X)
//				System.out.println(c1.getPost());
//				
//				/*
//				 * Hibernate: select c1_0.id,c1_0.content,p1_0.id,p1_0.content,p1_0.title from Comment c1_0 left join Post p1_0 on p1_0.id=c1_0.post_id where c1_0.id=?
//					Comment [id=1, content=Commnet 1 Content]
//					Post [id=1, title=Post 1, content=Post 1 Content]
//				 */
//
//			}
			
			// #C
			// Comment 1 건 find()
			// Comment 의 FetchType을 LAZY로 변경
			// Comment 만 가져온다. join X
			{
				Comment c1 = em.find(Comment.class, 1);
				System.out.println(c1);

				try {
					Thread.sleep(5000);
				} catch (Exception e) {
					e.printStackTrace();
				}

				// Comment와 연관된 Post를 가져올 때 다시 sql 수행 (X)
				System.out.println(c1.getPost());

				/*
				 * Hibernate: select c1_0.id,c1_0.content,c1_0.post_id from Comment c1_0 where c1_0.id=?
					Comment [id=1, content=Commnet 1 Content]
					Hibernate: select p1_0.id,p1_0.content,p1_0.title from Post p1_0 where p1_0.id=?
					Post [id=1, title=Post 1, content=Post 1 Content]
				 */

			}
			
			em.getTransaction().commit(); // update 수행
		} finally {
			em.close();
		}
		
		
	}

}
```

### 기존 Post 에 새 Comment 추가

### src/main/java/com/mycom/myapp

### Test3.java

```java
package com.mycom.myapp;

import java.util.HashMap;
import java.util.Map;

import org.hibernate.jpa.HibernatePersistenceProvider;

import com.mycom.myapp.config.MyPersistenceUnitInfo;
import com.mycom.myapp.entity.Comment;
import com.mycom.myapp.entity.Post;

import jakarta.persistence.EntityManager;
import jakarta.persistence.EntityManagerFactory;

public class Test3 {

	public static void main(String[] args) {

		Map<String, String> props = new HashMap<>();
		props.put("hibernate.show_sql", "true");	// sql 명령문을 확인할 수 있다.
//		props.put("hibernate.hbm2ddl.auto", "create");	// 속성에 create, update 등이 올 수 있다.
		
		EntityManagerFactory emf = new HibernatePersistenceProvider().createContainerEntityManagerFactory(new MyPersistenceUnitInfo(), props);
		EntityManager em = emf.createEntityManager();
		
		try {
			em.getTransaction().begin();
			
			// 기존 Post 에 새 Comment 추가
			{
				// 기존 Post <- find()
				// 새 Comment <- Entity 객체 생성
				// 새 Comment Entity에 기존 Post Entity 연결
				// 새 Comment Entity를 persist
				Post p = em.find(Post.class, 1);
				
				Comment c3 = new Comment();
				c3.setContent("Comment 3 Cotent");
				
				c3.setPost(p);
				
				em.persist(c3);
				
			}
			
			em.getTransaction().commit(); // update 수행
		} finally {
			em.close();
		}
			
	}

}
```

# JPABasic_8_OneToMany 프로젝트 생성

- JPABasic_7_ManyToOne 프로젝트 복사하여 JPABasic_8_OneToMany 프로젝트 생성
- jpa_basic_8 스키마 생성

### src/main/java/com/mycom/myapp

### config/MyPersistenceUnitInfo.java

```java
package com.mycom.myapp.config;

import java.net.URL;
import java.util.List;
import java.util.Properties;

import javax.sql.DataSource;

import com.zaxxer.hikari.HikariDataSource;

import jakarta.persistence.SharedCacheMode;
import jakarta.persistence.ValidationMode;
import jakarta.persistence.spi.ClassTransformer;
import jakarta.persistence.spi.PersistenceUnitInfo;
import jakarta.persistence.spi.PersistenceUnitTransactionType;

// META-INF/persistence.xml 대체
public class MyPersistenceUnitInfo implements PersistenceUnitInfo {

	@Override
	public String getPersistenceUnitName() {
		return "my-pu";
	}

	@Override
	public String getPersistenceProviderClassName() {
		return "org.hibernate.jpa.HibernatePersistenceProvider";
	}

	@Override
	public PersistenceUnitTransactionType getTransactionType() {
		return PersistenceUnitTransactionType.RESOURCE_LOCAL;
	}

	@Override
	public DataSource getJtaDataSource() {
		HikariDataSource dataSource = new HikariDataSource();
		dataSource.setJdbcUrl("jdbc:mysql://localhost:3306/jpa_basic_8");
		dataSource.setUsername("root");
		dataSource.setPassword("root");
		return dataSource;
	}

	@Override
	public DataSource getNonJtaDataSource() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<String> getMappingFileNames() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<URL> getJarFileUrls() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public URL getPersistenceUnitRootUrl() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<String> getManagedClassNames() {
		return List.of("com.mycom.myapp.entity.Post", "com.mycom.myapp.entity.Comment");
	}

	@Override
	public boolean excludeUnlistedClasses() {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public SharedCacheMode getSharedCacheMode() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public ValidationMode getValidationMode() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Properties getProperties() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public String getPersistenceXMLSchemaVersion() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public ClassLoader getClassLoader() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void addTransformer(ClassTransformer transformer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public ClassLoader getNewTempClassLoader() {
		// TODO Auto-generated method stub
		return null;
	}

}
```

### entity/Post.java

```java
package com.mycom.myapp.entity;

import java.util.List;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.OneToMany;

// Owner Entity
@Entity
public class Post {
	
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private int id;
	
	private String title;
	
	private String content;
	
	// #1 ~ #3
//	@OneToMany
//	private List<Comment> comments;
	
	// #6
	@OneToMany(cascade = CascadeType.PERSIST)
	private List<Comment> comments;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getTitle() {
		return title;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	public List<Comment> getComments() {
		return comments;
	}

	public void setComments(List<Comment> comments) {
		this.comments = comments;
	}

	@Override
	public String toString() {
		return "Post [id=" + id + ", title=" + title + ", content=" + content + "]";
	}
	
}

```

### entity/Comment.java

```java
package com.mycom.myapp.entity;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToOne;

// Non Owner Entity
@Entity
public class Comment {

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private int id;

	private String content;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	@Override
	public String toString() {
		return "Comment [id=" + id + ", content=" + content + "]";
	}

}

```

### Test.java

```java
package com.mycom.myapp;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.hibernate.jpa.HibernatePersistenceProvider;

import com.mycom.myapp.config.MyPersistenceUnitInfo;
import com.mycom.myapp.entity.Comment;
import com.mycom.myapp.entity.Post;

import jakarta.persistence.EntityManager;
import jakarta.persistence.EntityManagerFactory;

public class Test {

	public static void main(String[] args) {

		Map<String, String> props = new HashMap<>();
		props.put("hibernate.show_sql", "true");	// sql 명령문을 확인할 수 있다.
		props.put("hibernate.hbm2ddl.auto", "create");	// 속성에 create, update 등이 올 수 있다.
		
		EntityManagerFactory emf = new HibernatePersistenceProvider().createContainerEntityManagerFactory(new MyPersistenceUnitInfo(), props);
		EntityManager em = emf.createEntityManager();
		
		try {
			em.getTransaction().begin();
			
			// #1 테이블 생성 확인
//			{
//				/*
//				 * Hibernate: create table Comment (id integer not null auto_increment, content varchar(255), primary key (id)) engine=InnoDB
//					Hibernate: create table Post (id integer not null auto_increment, content varchar(255), title varchar(255), primary key (id)) engine=InnoDB
//					Hibernate: create table Post_Comment (Post_id integer not null, comments_id integer not null) engine=InnoDB
//					Hibernate: alter table Post_Comment add constraint UK5nd2ucnctmvwq31ovab2vi00x unique (comments_id)
//					Hibernate: alter table Post_Comment add constraint FK1yqm25y6mj9vmmxj4ev7aj2q1 foreign key (comments_id) references Comment (id)
//					Hibernate: alter table Post_Comment add constraint FKgtvmchqpjf5ysbhyg52cofvrn foreign key (Post_id) references Post (id)
//				 */
//			}
			
			// #2
			// Post Entity 1 개 persist
			// Post 1건 insert OK
//			{
//				Post p = new Post();
//				p.setTitle("Post 1");
//				p.setContent("Post 1 Content");
//				
//				em.persist(p);
//				
//				/*
//				 * Hibernate: insert into Post (content,title) values (?,?)
//				 */
//				
//			}
			
			// #3
			// Comment Entity 2 개 persist
			// Comment 2 건 insert OK 
			// (but, 올바르지 않다. Post_Comment에 이 Comment들이 어떤 Post의 Comment 들인지 데이터가 추가로 필요한 상황)
//			{
//				Comment c1 = new Comment();
//				c1.setContent("comment 1 Content");
//				
//				Comment c2 = new Comment();
//				c2.setContent("comment 2 Content");
//
//				em.persist(c1);
//				em.persist(c2);
//
//			}
			
			// #4
			// Post 1, Comment Entity 2 개 persist
			// Post - Comment 연결 (O)
//			{
//				Post p = new Post();
//				p.setTitle("Post 1");
//				p.setContent("Post 1 Content");
//
//				Comment c1 = new Comment();
//				c1.setContent("comment 1 Content");
//
//				Comment c2 = new Comment();
//				c2.setContent("comment 2 Content");
//				
//				// 연결
//				p.setComments(List.of(c1, c2));
//
//				em.persist(p);
//				em.persist(c1);
//				em.persist(c2);
//
//				/*
//				 * Hibernate: insert into Post (content,title) values (?,?)
//					Hibernate: insert into Comment (content) values (?)
//					Hibernate: insert into Comment (content) values (?)
//					Hibernate: insert into Post_Comment (Post_id,comments_id) values (?,?)
//					Hibernate: insert into Post_Comment (Post_id,comments_id) values (?,?)
//				 */
//
//			}
			
			// #5
			// Post 1, Comment 2 Entity 생성
			// Post - Comment 연결 (O)
			// Post만 persist
			// 오류 발생
			// org.hibernate.TransientObjectException: object references an unsaved transient instance - save the transient instance before flushing: com.mycom.myapp.entity.Comment
//			{
//				Post p = new Post();
//				p.setTitle("Post 1");
//				p.setContent("Post 1 Content");
//
//				Comment c1 = new Comment();
//				c1.setContent("comment 1 Content");
//
//				Comment c2 = new Comment();
//				c2.setContent("comment 2 Content");
//
//				// 연결
//				p.setComments(List.of(c1, c2));
//
//				em.persist(p); // Post만 persist
////				em.persist(c1);
////				em.persist(c2);
//
//			}
			
			// #6
			// Post 1, Comment 2 Entity 생성
			// Post - Comment 연결 (O)
			// Post만 persist
			// 오류 발생
			// org.hibernate.TransientObjectException: object references an unsaved
			// transient instance - save the transient instance before flushing:
			// com.mycom.myapp.entity.Comment
			{
				Post p = new Post();
				p.setTitle("Post 1");
				p.setContent("Post 1 Content");

				Comment c1 = new Comment();
				c1.setContent("comment 1 Content");

				Comment c2 = new Comment();
				c2.setContent("comment 2 Content");

				// 연결
				p.setComments(List.of(c1, c2));

				em.persist(p); // Post만 persist
//				em.persist(c1);
//				em.persist(c2);
				
				/*
				 * Hibernate: insert into Post (content,title) values (?,?)
					Hibernate: insert into Comment (content) values (?)
					Hibernate: insert into Comment (content) values (?)
					Hibernate: insert into Post_Comment (Post_id,comments_id) values (?,?)
					Hibernate: insert into Post_Comment (Post_id,comments_id) values (?,?)
				 */

			}
			
			em.getTransaction().commit(); // update 수행
			
		} finally {
			em.close();
		}
		
		
	}

}

```

### find

### src/main/java/com/mycom/myapp

### entity/Post.java

```java
package com.mycom.myapp.entity;

import java.util.List;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.OneToMany;

// Owner Entity
@Entity
public class Post {
	
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private int id;
	
	private String title;
	
	private String content;
	
	// #1 ~ #5
	// #A, #B
	// #가 (Test3)
	@OneToMany
	private List<Comment> comments;
	
	// #6
//	@OneToMany(cascade = CascadeType.PERSIST)
//	private List<Comment> comments;
	
	// #C
//	@OneToMany(fetch = FetchType.EAGER)
//	private List<Comment> comments;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getTitle() {
		return title;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	public List<Comment> getComments() {
		return comments;
	}

	public void setComments(List<Comment> comments) {
		this.comments = comments;
	}

	@Override
	public String toString() {
		return "Post [id=" + id + ", title=" + title + ", content=" + content + "]";
	}
	
}

```

### entity/Comment.java

```java
package com.mycom.myapp.entity;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToOne;

// Non Owner Entity
@Entity
public class Comment {

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private int id;

	private String content;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	@Override
	public String toString() {
		return "Comment [id=" + id + ", content=" + content + "]";
	}

}

```

### Test2.java

```java
package com.mycom.myapp;

import java.util.HashMap;
import java.util.Map;

import org.hibernate.jpa.HibernatePersistenceProvider;

import com.mycom.myapp.config.MyPersistenceUnitInfo;
import com.mycom.myapp.entity.Comment;
import com.mycom.myapp.entity.Post;

import jakarta.persistence.EntityManager;
import jakarta.persistence.EntityManagerFactory;

public class Test2 {

	public static void main(String[] args) {

		Map<String, String> props = new HashMap<>();
		props.put("hibernate.show_sql", "true");	// sql 명령문을 확인할 수 있다.
//		props.put("hibernate.hbm2ddl.auto", "create");	// 속성에 create, update 등이 올 수 있다.
		
		EntityManagerFactory emf = new HibernatePersistenceProvider().createContainerEntityManagerFactory(new MyPersistenceUnitInfo(), props);
		EntityManager em = emf.createEntityManager();
		
		try {
			em.getTransaction().begin();
			
			// #A
			// Post 1 건 find()
			// join (X) Post 1 건 select
			// @OneToMany FetchType 이 LAZY
//			{
//				Post post = em.find(Post.class, 1);
//				System.out.println(post);
//				
//				try {
//					Thread.sleep(5000);
//				}catch (Exception e) {
//					e.printStackTrace();
//				}
//				
//				// Post Entity 의 연관관계의 comments를 사용하는 시점에 다시 select 수행
//				System.out.println(post.getComments());
//				
//				/* 실행 결과
//				 * Hibernate: select p1_0.id,p1_0.content,p1_0.title from Post p1_0 where p1_0.id=?
//					Post [id=1, title=Post 1, content=Post 1 Content]
//					Hibernate: select c1_0.Post_id,c1_1.id,c1_1.content from Post_Comment c1_0 join Comment c1_1 on c1_1.id=c1_0.comments_id where c1_0.Post_id=?
//					[Comment [id=1, content=comment 1 Content], Comment [id=2, content=comment 2 Content]]
//				 */
//				
//			}
			
			// #B
//			{
//				Comment c = em.find(Comment.class, 1);
//				System.out.println(c);
//				
//				/* 실행 결과
//				 * Hibernate: select c1_0.id,c1_0.content from Comment c1_0 where c1_0.id=?
//					Comment [id=1, content=comment 1 Content]
//				 */
//				
//			}
			
			// #C
			// Post 1 건 find()
			// Post FetchType 이 EAGER
			// join 수행, 미리 Post + Comment 함께 가지고 온다.
			{
				Post post = em.find(Post.class, 1);
				System.out.println(post);
				
				/* 실행 결과 (try X)
				 * Hibernate: select p1_0.id,p1_0.content,p1_0.title,c1_0.Post_id,c1_1.id,c1_1.content from Post p1_0 left join Post_Comment c1_0 on p1_0.id=c1_0.Post_id left join Comment c1_1 on c1_1.id=c1_0.comments_id where p1_0.id=?
					Post [id=1, title=Post 1, content=Post 1 Content]
				 */
				
				try {
					Thread.sleep(5000);
				}catch (Exception e) {
					e.printStackTrace();
				}
				
				// Post Entity 의 연관관계의 comments를 사용하는 시점에 다시 select 수행 X
				System.out.println(post.getComments());
				
				/* 실행 결과
				 * Hibernate: select p1_0.id,p1_0.content,p1_0.title,c1_0.Post_id,c1_1.id,c1_1.content from Post p1_0 left join Post_Comment c1_0 on p1_0.id=c1_0.Post_id left join Comment c1_1 on c1_1.id=c1_0.comments_id where p1_0.id=?
					Post [id=1, title=Post 1, content=Post 1 Content]
					[Comment [id=1, content=comment 1 Content], Comment [id=2, content=comment 2 Content]]

				 */

			}
			
			em.getTransaction().commit(); // update 수행
		} finally {
			em.close();
		}
		
		
	}

}

```

### 기존 Post 에 새 Comment 추가

### src/main/java/com/mycom/myapp

### Test3.java

```java
package com.mycom.myapp;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.hibernate.jpa.HibernatePersistenceProvider;

import com.mycom.myapp.config.MyPersistenceUnitInfo;
import com.mycom.myapp.entity.Comment;
import com.mycom.myapp.entity.Post;

import jakarta.persistence.EntityManager;
import jakarta.persistence.EntityManagerFactory;

public class Test3 {

	public static void main(String[] args) {

		Map<String, String> props = new HashMap<>();
		props.put("hibernate.show_sql", "true");	// sql 명령문을 확인할 수 있다.
//		props.put("hibernate.hbm2ddl.auto", "create");	// 속성에 create, update 등이 올 수 있다.
		
		EntityManagerFactory emf = new HibernatePersistenceProvider().createContainerEntityManagerFactory(new MyPersistenceUnitInfo(), props);
		EntityManager em = emf.createEntityManager();
		
		try {
			em.getTransaction().begin();
			
			// #가
			// 기존 Post 에 새 Comment 추가
			{
				// 기존 Post <- find()
				// 새 Comment <- Entity 객체 생성
				// Post Entity에 새 Comment Entity 연결 
				// 		Post의 Comment List를 가져와서 add (새 Comment)
				// 새 Comment Entity를 persist
				// @OneToMany에서 Post에 새로운 Comment의 등록은 기존 Post Entity의 Comment를 삭제, 등록 과정으로 처리
				Post p = em.find(Post.class, 1);

				Comment c3 = new Comment();
				c3.setContent("comment 3 Content");
				
				// 연결
				System.out.println(p.getComments().size());
				p.getComments().add(c3);

				em.persist(c3);

				/*
				 * Hibernate: select p1_0.id,p1_0.content,p1_0.title from Post p1_0 where p1_0.id=?
					Hibernate: insert into Comment (content) values (?)
					Hibernate: delete from Post_Comment where Post_id=?
					Hibernate: insert into Post_Comment (Post_id,comments_id) values (?,?)
				 */
				
			}
			
			em.getTransaction().commit(); // update 수행
		} finally {
			em.close();
		}
		
	}

}
```

# OneToMany vs ManyToOne

- ManyToOne은 Ownership을 Many 클래스가 갖는다.
    
    ex) one - post, Many - comment일 경우 comment가 Ownership을 갖는다. 
    
    (FK를 comment가 가진다.)
    
- OneToMany는 Ownership을 One 클래스가 갖는다.
    
    ex) one - post, Many - comment일 경우 post가 Ownership을 갖는다. 
    
    (FK를 post가 가진다.)
    

- 댓글과 같은 경우에는 하나의 게시글에 새로운 댓글이 추가될 때 다른 댓글은 변경되지 않으므로 ManyToOne을 사용하는 것이 좋다.
- 첨부파일과 같은 경우에는 하나의 게시글에 첨부파일이 변경될 때 이전에 저장된 첨부파일을 모두 삭제하고 다시 저장하므로 OneToMany를 사용하는 것이 좋다.